/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./server/client/js/teams.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./server/client/js/character.js":
/*!***************************************!*\
  !*** ./server/client/js/character.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* \r\n    ========================\r\n        Character Object\r\n    ========================\r\n*/\nvar character = {\n  deathCharacter: false,\n\n  /* Sprites */\n  currentSprite: {\n    x: 0,\n    y: 5,\n    flip: 1\n  },\n  spriteSheet: {\n    img: null,\n    width: 64,\n    height: 64\n  },\n\n  /* Animations */\n  animationSpeed: 250,\n  moveInterval: undefined,\n\n  /* Matrix position */\n  posY: null,\n  posX: null,\n\n  /* Load the sprites for the given character */\n  load: function load(name, callback) {\n    var _this = this;\n\n    /* Load sprite for character */\n    var sprite = new Image();\n\n    sprite.onload = function () {\n      _this.spriteSheet.img = sprite;\n      callback();\n    };\n\n    sprite.src = \"../assets/characters/\".concat(name);\n  },\n\n  /* Change the image when moving forward */\n  onMovingForward: function onMovingForward() {\n    if (this.currentSprite.y === 5) this.currentSprite.x = 0;\n    this.currentSprite.y = 2;\n    this.createInterval();\n  },\n  onMovingBackwards: function onMovingBackwards() {\n    if (this.currentSprite.y === 5) this.currentSprite.x = 0;\n    this.currentSprite.y = 0;\n    this.createInterval();\n  },\n  onMovingLeft: function onMovingLeft() {\n    if (this.currentSprite.y === 5) this.currentSprite.x = 0;\n    this.currentSprite.y = 1;\n    this.currentSprite.flip = -1;\n    this.createInterval();\n  },\n  onMovingRight: function onMovingRight() {\n    if (this.currentSprite.y === 5) this.currentSprite.x = 0;\n    this.currentSprite.y = 1;\n    this.currentSprite.flip = 1;\n    this.createInterval();\n  },\n  onMovingForwardLeft: function onMovingForwardLeft() {\n    if (this.currentSprite.y === 5) this.currentSprite.x = 0;\n    this.currentSprite.y = 3;\n    this.currentSprite.flip = -1;\n    this.createInterval();\n  },\n  onMovingForwardRight: function onMovingForwardRight() {\n    if (this.currentSprite.y === 5) this.currentSprite.x = 0;\n    this.currentSprite.y = 3;\n    this.currentSprite.flip = 1;\n    this.createInterval();\n  },\n  onMovingBackwardsRight: function onMovingBackwardsRight() {\n    if (this.currentSprite.y === 5) this.currentSprite.x = 0;\n    this.currentSprite.y = 4;\n    this.currentSprite.flip = 1;\n    this.createInterval();\n  },\n  onMovingBackwardsLeft: function onMovingBackwardsLeft() {\n    if (this.currentSprite.y === 5) this.currentSprite.x = 0;\n    this.currentSprite.y = 4;\n    this.currentSprite.flip = -1;\n    this.createInterval();\n  },\n  createInterval: function createInterval() {\n    var _this2 = this;\n\n    this.moveInterval = setInterval(function () {\n      _this2.currentSprite.x++;\n      if (_this2.currentSprite.x > 3) _this2.currentSprite.x = 0;\n    }, this.animationSpeed);\n  },\n\n  /* Delete  */\n  onMovingStop: function onMovingStop() {\n    this.currentSprite.y = 5;\n  },\n  stopMoving: function stopMoving() {\n    clearInterval(this.moveInterval);\n    this.moveInterval = null;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (character);\n\n//# sourceURL=webpack:///./server/client/js/character.js?");

/***/ }),

/***/ "./server/client/js/classes/Engine.js":
/*!********************************************!*\
  !*** ./server/client/js/classes/Engine.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Engine; });\n/* harmony import */ var _character_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../character.js */ \"./server/client/js/character.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n/**\r\n * ============================\r\n *         ENGINE CLASS\r\n * ============================\r\n */\n\nvar Engine = /*#__PURE__*/function () {\n  function Engine(map, collisionMatrix, shadowMatrix, tileset, canvas, skin) {\n    var _this = this;\n\n    _classCallCheck(this, Engine);\n\n    this.resizeCanvas = function () {\n      //let self = engine\n      var tempWidth = _this.tileMap.width,\n          tempHeight = _this.tileMap.height;\n      /* Dimension of the general canvas */\n\n      _this.canvas.width = window.innerWidth;\n      _this.canvas.height = _this.canvas.width * _this.frameRatio < window.innerHeight ? _this.canvas.width * _this.frameRatio : window.innerHeight;\n      /* Tile width and height responsive */\n\n      _this.tile.width = _this.canvas.width / _this.screenTiles.x;\n      _this.tile.height = _this.canvas.height / _this.screenTiles.y;\n      /* Dimensions of the tile map */\n\n      _this.tileMap.width = _this.tileMap.tiles[0].length * _this.tile.width;\n      _this.tileMap.height = _this.tileMap.tiles.length * _this.tile.height;\n      /* Start points responsive -> rule of 3*/\n\n      _this.tileMap.startX = _this.tileMap.startX * _this.tileMap.width / tempWidth;\n      _this.tileMap.startY = _this.tileMap.startY * _this.tileMap.height / tempHeight;\n      /* Camera smoothness ratio */\n\n      _this.cameraSmoothness.limitX = _this.canvas.width * .045;\n      _this.cameraSmoothness.limitY = _this.canvas.height * .045;\n      /* Bullet's size */\n\n      _this.bulletSprite.width = _this.canvas.width * .02;\n      _this.bulletSprite.height = _this.canvas.width * .02;\n      /* bonusKit sizes */\n\n      _this.kits.width = _this.tile.width / 2;\n      _this.kits.height = _this.tile.height / 2;\n      /* Set player's position */\n\n      _this.playerRelativePosition = _this.getPlayerRelativePosition();\n    };\n\n    this.triggerShooting = function (dir, spriteY) {\n      // Testing variables for shooting\n      //console.log(`able to shoot: ${this.ableToShoot} ; controls shoot: ${this.controls.shoot} ; chat inactive: ${this.chat.active} ; ammo : ${this.currentAmmo} ; reloading: ${this.reloading}`)\n      if (_this.reloading && !window.mobileCheck()) {\n        if (!_this.sounds.empty.paused) _this.sounds.empty.currentTime = 0;\n\n        _this.sounds.empty.play();\n      }\n\n      if (_this.ableToShoot && _this.controls.shoot && !_this.chat.active && _this.currentAmmo && !_this.reloading) {\n        _this.ableToShoot = false;\n        setTimeout(function () {\n          _this.ableToShoot = true;\n        }, _this.shootingDelay);\n        /* Fire animation */\n\n        setTimeout(function () {\n          _this.emitBullet(dir, spriteY);\n        }, 70);\n      }\n    };\n\n    /* General variables */\n    this.canvas = canvas;\n    this.context = this.canvas.getContext(\"2d\");\n    /* List with single tiles -> no-repeated img -> Use to load only one image for each value */\n\n    this.tileList = [];\n    /* Array that stores -> id = in the map matrix AND img = Image object */\n\n    this.tileImages = [];\n    this.localGame = null;\n    this.skin = skin;\n    /* Total amount of ammo for the character selected */\n\n    this.playerAmmunition = null;\n    this.currentAmmo = null;\n    this.reloading = false;\n    this.shootingDelay = null;\n    this.ableToShoot = true;\n    /* Html <p> that shows the amount of bullets in the charger */\n\n    this.bulletsHTMLElement = document.getElementById('charger');\n    this.character = _character_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    /* Tile properties */\n\n    this.tile = {\n      width: null,\n      height: null\n    };\n    /*  TileMap Object -> properties and tiles  */\n\n    this.tileMap = {\n      tileSet: tileset,\n      tiles: map,\n      startX: 200,\n      startY: 200,\n      width: 1280,\n      height: 720\n    };\n    /* Tiles per screen */\n\n    this.screenTiles = {\n      x: 16,\n      y: 9\n    };\n    this.frameDefaultDimensions = {\n      width: 1280,\n      height: 720\n    };\n    /* Player stats */\n\n    this.playerStats = null;\n    /* Calculate the average ratio of the screen */\n\n    this.frameRatio = this.frameDefaultDimensions.height / this.frameDefaultDimensions.width;\n    this.offSet = {\n      x: null,\n      y: null,\n      xLimit: null,\n      yLimit: null\n    };\n    /* Relative position of player */\n\n    this.playerRelativePosition = null;\n    /* FPS Counter */\n\n    this.lastFrameTime = 0;\n    this.FPS = 0;\n    /* Static Animation */\n\n    this.staticAnimation = {\n      interval: null,\n      x: 0\n    };\n    /* Collisionable */\n\n    this.collisionMatrix = collisionMatrix;\n    /* Shadow matrix */\n\n    this.shadowMatrix = shadowMatrix;\n    this.shooting = false;\n    /* Animation */\n\n    this.animatedSprites = false;\n    /* Camera smoothness */\n\n    this.cartesianValueOfMovement = {\n      x: 0,\n      y: 0\n    };\n    this.cameraSmoothness = {\n      velX: .5,\n      velY: 2,\n      friction: .98,\n      offsetX: 0,\n      offsetY: 0\n    };\n    /* Bullets Image */\n\n    this.bulletSprite = {\n      width: null,\n      height: null,\n      img: null\n    };\n    /* Get the timings of the animation 0-4 */\n\n    this.animationTiming = 1;\n    /**\r\n     *  =========================\r\n     *          COLORS\r\n     *  =========================\r\n     */\n\n    this.colors = {\n      enemy: '#eb3d11',\n      self: ' #00b7ff',\n      ally: '#00ff00'\n    };\n    /* Sounds */\n\n    this.sounds = {\n      empty: new Audio('../assets/sounds/empty.mp3'),\n      silencer: new Audio('../assets/sounds/gunshot.mp3'),\n      shotgun: new Audio('../assets/sounds/Shotgun.mp3'),\n      laser: new Audio('../assets/sounds/laser.mp3'),\n      sniper: new Audio('../assets/sounds/sniper.mp3'),\n      reload: new Audio('../assets/sounds/reload.mp3'),\n      healing: new Audio('../assets/sounds/healing.mp3'),\n      footsteps: {}\n    };\n    /* Set default volumes */\n\n    this.sounds.healing.volume = .2;\n    this.sounds.reload.volume = .2;\n    /* Bonus kits that will be around the map */\n\n    this.kits = {};\n    /* Flag sprites in case they have to be loaded */\n\n    this.flags = {};\n    this.pointers = {};\n    /* gunshot sound radius -> in pixels */\n\n    this.soundWaves = {\n      bullets: 600,\n      footsteps: 200\n    };\n    window.addEventListener('resize', this.resizeCanvas);\n    if (window.mobileCheck()) window.addEventListener('deviceorientatio', this.resizeCanvas);\n    this.resizeCanvas();\n    this.load();\n  }\n  /* \r\n      =================\r\n          LOAD TILES\r\n      =================\r\n  */\n\n\n  _createClass(Engine, [{\n    key: \"load\",\n    value: function load() {\n      var _this2 = this;\n\n      console.log(this.tileList);\n      console.log(this.tileImages);\n      console.log(this.tileMap.tiles);\n      console.log(this.collisionMatrix);\n      console.log(this.shadowMatrix);\n\n      var pushImg = function pushImg(val) {\n        if (Array.isArray(val)) {\n          val.forEach(function (value) {\n            return pushImg(value);\n          });\n          _this2.animatedSprites = true;\n        } else {\n          if (val !== 0 && _this2.tileList.indexOf(val) < 0) _this2.tileList.push(val);\n        }\n      };\n      /* Retrieve single tile values */\n\n\n      for (var i = 0; i < this.tileMap.tiles.length; i++) {\n        for (var j = 0; j < this.tileMap.tiles[0].length; j++) {\n          pushImg(this.tileMap.tiles[i][j]);\n          pushImg(this.collisionMatrix[i][j]);\n          pushImg(this.shadowMatrix);\n        }\n      }\n\n      var loadedImages = 0; // Check if all images have been loaded\n\n      for (var _i = 0; _i < this.tileList.length; _i++) {\n        var tileImage = new Image();\n\n        tileImage.onload = function () {\n          if (++loadedImages >= _this2.tileList.length) {\n            _this2.bulletSprite.img = new Image();\n\n            _this2.bulletSprite.img.onload = function () {\n              _this2.loadCharacter();\n            };\n\n            _this2.bulletSprite.img.src = '../assets/resources/bullets.png';\n          }\n        };\n\n        tileImage.src = \"../assets/tiles/\".concat(this.tileMap.tileSet, \"/tile_00\").concat(this.tileList[_i] < 10 ? '0' + this.tileList[_i] : this.tileList[_i], \".png\");\n        this.tileImages.push({\n          id: this.tileList[_i],\n          img: tileImage\n        });\n      }\n    }\n  }, {\n    key: \"loadCharacter\",\n    value: function loadCharacter() {\n      var _this3 = this;\n\n      this.character.load(\"\".concat(this.skin, \".png\"), function () {\n        if (_this3.animatedSprites) _this3.setAnimationTiming();\n\n        _this3.loadBonusKits();\n      });\n    }\n    /* Load bonus kits */\n\n  }, {\n    key: \"loadBonusKits\",\n    value: function loadBonusKits() {\n      var _this4 = this;\n\n      var loaded = 0;\n\n      var onload = function onload() {\n        if (++loaded >= 2) {\n          _this4.loadFlags();\n        }\n      };\n      /* Load medical kit image */\n\n\n      this.kits.medical = new Image();\n      this.kits.medical.onload = onload;\n      this.kits.medical.src = '../assets/resources/medical-kit.png';\n      /* Load bullets kit image */\n\n      this.kits.bullets = new Image();\n      this.kits.bullets.onload = onload;\n      this.kits.bullets.src = '../assets/resources/bullets-kit.png';\n    }\n  }, {\n    key: \"loadFlags\",\n    value: function loadFlags() {\n      var _this5 = this;\n\n      /* if the game mode is not capture the flag then we're done loading assets */\n      if (this.mode !== 2) {\n        this.closeLoadingScreen();\n        requestAnimationFrame(this.render);\n        return;\n      }\n      /* if the game mode is capture the flag then load the flag sprites */\n\n\n      var loaded = 0;\n\n      var callback = function callback() {\n        if (++loaded >= 4) {\n          _this5.closeLoadingScreen();\n\n          requestAnimationFrame(_this5.render);\n        }\n      };\n\n      this.flags.blue = new Image();\n      this.flags.blue.onload = callback;\n      this.flags.blue.src = '../assets/resources/blue-flag.png';\n      this.flags.red = new Image();\n      this.flags.red.onload = callback;\n      this.flags.red.src = '../assets/resources/red-flag.png';\n      /* Load flag pointers too */\n\n      this.pointers.blue = new Image();\n      this.pointers.blue.onload = callback;\n      this.pointers.blue.src = '../assets/resources/blue-flag-pointer.png';\n      this.pointers.red = new Image();\n      this.pointers.red.onload = callback;\n      this.pointers.red.src = '../assets/resources/red-flag-pointer.png';\n    }\n    /* Shut loading screen once every element's been downloaded */\n\n  }, {\n    key: \"closeLoadingScreen\",\n    value: function closeLoadingScreen() {\n      console.log(this.kits);\n      /* Show game */\n\n      var body = document.getElementsByTagName('body')[0];\n      body.classList.remove('background-connect-frame');\n      document.getElementById('site-ajax-loader').style.display = 'none';\n      document.getElementById('site-game').style.display = 'block';\n      document.getElementById('background-frame').style.display = 'none';\n    }\n    /* Auto resize the canvas when the screen is resized */\n\n  }, {\n    key: \"calculateOffset\",\n\n    /**\r\n     * =================================\r\n     *  GENERAL FUNCTIONS FOR RENDERING\r\n     * =================================\r\n     */\n\n    /* Calculate which tiles are to be drawn within the screen */\n    value: function calculateOffset() {\n      this.offSet.x = this.tileMap.startX < 0 ? Math.floor(-this.tileMap.startX / this.tile.width) : 0;\n      this.offSet.y = this.tileMap.startY < 0 ? Math.floor(-this.tileMap.startY / this.tile.height) : 0;\n      var offsetX = this.screenTiles.x + Math.floor(-this.tileMap.startX / this.tile.width) + 1;\n      var offsetY = this.screenTiles.y + Math.floor(-this.tileMap.startY / this.tile.height) + 1;\n      this.offSet.xLimit = offsetX > this.tileMap.tiles[0].length ? this.tileMap.tiles[0].length : offsetX;\n      this.offSet.yLimit = offsetY > this.tileMap.tiles.length ? this.tileMap.tiles.length : offsetY;\n    }\n    /* Draw Map function */\n\n  }, {\n    key: \"drawMap\",\n    value: function drawMap() {\n      for (var i = this.offSet.y; i < this.offSet.yLimit; i++) {\n        for (var j = this.offSet.x; j < this.offSet.xLimit; j++) {\n          this.drawTile(j, i, this.tileMap.tiles);\n        }\n      }\n    }\n  }, {\n    key: \"drawShadows\",\n    value: function drawShadows() {\n      for (var i = this.offSet.y; i < this.offSet.yLimit; i++) {\n        for (var j = this.offSet.x; j < this.offSet.xLimit; j++) {\n          if (this.shadowMatrix[i][j]) this.drawTile(j, i, this.shadowMatrix);\n        }\n      }\n    }\n    /* Draw objects from collision matrix */\n\n  }, {\n    key: \"drawObjects\",\n    value: function drawObjects() {\n      for (var i = this.offSet.y; i < this.offSet.yLimit; i++) {\n        for (var j = this.offSet.x; j < this.offSet.xLimit; j++) {\n          if (this.collisionMatrix[i][j]) this.drawTile(j, i, this.collisionMatrix);\n        }\n      }\n    }\n    /* Draw single tile on canvas */\n\n  }, {\n    key: \"drawTile\",\n    value: function drawTile(xi, yi, matrix) {\n      var _this6 = this;\n\n      var indexImage = Array.isArray(matrix[yi][xi]) ? this.tileImages.findIndex(function (elem) {\n        return elem.id === matrix[yi][xi][_this6.animationTiming];\n      }) : this.tileImages.findIndex(function (elem) {\n        return elem.id === matrix[yi][xi];\n      });\n      if (matrix[yi][xi] !== 0) this.context.drawImage(this.tileImages[indexImage].img, xi * this.tile.width + this.tileMap.startX, yi * this.tile.height + this.tileMap.startY, this.tile.width, this.tile.height);\n    }\n  }, {\n    key: \"drawCharacter\",\n    value: function drawCharacter() {\n      var spriteSheetPos = this.playerStats.life === 0 ? {\n        x: 1,\n        y: 8\n      } : this.character.currentSprite;\n      this.context.drawImage(this.character.spriteSheet.img, spriteSheetPos.x * this.character.spriteSheet.width, spriteSheetPos.y * this.character.spriteSheet.height, this.character.spriteSheet.width, this.character.spriteSheet.height, this.playerRelativePosition.posX, this.playerRelativePosition.posY, this.tile.width, this.tile.height);\n    }\n    /* In case of animated tile -> set the timing for every tile */\n\n  }, {\n    key: \"setAnimationTiming\",\n    value: function setAnimationTiming() {\n      var _this7 = this;\n\n      setInterval(function () {\n        if (_this7.animationTiming === 4) _this7.animationTiming = 0;else _this7.animationTiming++;\n      }, 350);\n    }\n    /**\r\n     *  =======================================\r\n     *    FUNCTIONS TO CALCULATE POSITIONS\r\n     *  =======================================\r\n     */\n\n  }, {\n    key: \"getPlayerPosition\",\n    value: function getPlayerPosition() {\n      var posX = Math.floor((this.tileMap.width / 2 - this.tileMap.startX) / this.tile.width);\n      var posY = Math.floor((this.tileMap.height / 2 - this.tileMap.startY) / this.tile.height); //console.log(`${posX}, ${posY}`)\n\n      return {\n        posX: posX,\n        posY: posY\n      };\n    }\n    /* Get player realtive position to the screen size */\n\n  }, {\n    key: \"getPlayerRelativePosition\",\n    value: function getPlayerRelativePosition() {\n      var posX = this.screenTiles.x * this.tile.width / 2 - this.tile.width / 2;\n      var posY = this.screenTiles.y * this.tile.height / 2 - this.tile.height / 2;\n      return {\n        posX: posX,\n        posY: posY\n      };\n    }\n    /* returns position of a given position in the matrix relative to the screen */\n\n  }, {\n    key: \"getTilesRelativePosition\",\n    value: function getTilesRelativePosition(x, y) {\n      var posX = x * this.tile.width + this.tileMap.startX;\n      var posY = y * this.tile.height + this.tileMap.startY;\n      return {\n        posX: posX,\n        posY: posY\n      };\n    }\n    /* Draw life of an entity */\n\n  }, {\n    key: \"drawLife\",\n    value: function drawLife(posX, posY, life, color) {\n      this.context.beginPath();\n      this.context.rect(posX, posY, this.tile.width, this.tile.height / 10);\n      this.context.stroke();\n      this.context.beginPath();\n      this.context.rect(posX, posY, this.tile.width * life / 100, this.tile.height / 10);\n      this.context.fillStyle = color;\n      this.context.fill();\n      this.context.closePath();\n      this.context.restore();\n    }\n    /** \r\n     *  =========================\r\n     *      SHOOTING MECHANICS\r\n     *  =========================\r\n    */\n\n    /* Shooting timing */\n\n  }]);\n\n  return Engine;\n}();\n\n\n\n//# sourceURL=webpack:///./server/client/js/classes/Engine.js?");

/***/ }),

/***/ "./server/client/js/classes/Joystick.js":
/*!**********************************************!*\
  !*** ./server/client/js/classes/Joystick.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Joystick; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * ===============================\r\n *        Joystick Class\r\n * ===============================\r\n * \r\n * @constructor\r\n * \r\n * @param canvas {Object} - HTML canvas element where the joystick will be drawn\r\n * @param position {Object} - X and Y positions to draw the joystick\r\n * @param radius {Integer} - Radius of the outter circle -> inner will be drawn based on this value (60% of outter)\r\n * @param internalFillColor {String} (optional) - Internal color of inner circle\r\n * @param internalStrokeColor {String} (optional) - Border color of inner circle\r\n * \r\n */\nvar Joystick = /*#__PURE__*/function () {\n  function Joystick(canvas, character, emitPosition, emitBullet, emitReload, internalFillColor, internalStrokeColor) {\n    var _this = this;\n\n    _classCallCheck(this, Joystick);\n\n    this.resize = function () {\n      /* radius of outter circle */\n      _this.radius = _this.canvas.width * .07;\n      /* Stablishing dimensions */\n\n      _this.position = {\n        x: _this.radius + _this.canvas.width * .07,\n        y: _this.canvas.height - (_this.radius + _this.canvas.height * 0.1)\n      };\n      /* Outer circle */\n\n      _this.outterCircle = {\n        x: _this.position.x,\n        y: _this.position.y,\n        radius: _this.radius\n      };\n      /* Inner circle */\n\n      _this.innerCircle = {\n        x: _this.position.x,\n        y: _this.position.y,\n        radius: _this.radius * .60\n      };\n      /* Shoot button */\n\n      _this.shootButton = {\n        x: _this.canvas.width - _this.radius - _this.canvas.width * .07,\n        y: _this.position.y,\n        radius: _this.radius * .8\n      };\n      /* Reload button */\n\n      _this.reloadButton = {\n        x: _this.canvas.width - _this.radius,\n        y: _this.position.y - _this.shootButton.radius - _this.canvas.height * .06,\n        radius: _this.radius * .5\n      };\n\n      _this.drawJoystick();\n    };\n\n    this.handleStart = function (e) {\n      /* Determine if user is clicking the inner circle -> implemented using pythagoras */\n      e.preventDefault();\n\n      for (var i = 0; i < e.changedTouches.length; i++) {\n        /* If touching the joystick */\n        if (Math.pow(e.changedTouches[i].pageX - _this.innerCircle.x, 2) + Math.pow(e.changedTouches[i].pageY - _this.innerCircle.y, 2) <= Math.pow(_this.innerCircle.radius, 2)) {\n          _this.dragging = true;\n\n          _this.touchingFingers.push(e.changedTouches[i].identifier);\n\n          _this.indexJoystick = _this.touchingFingers.length - 1;\n        }\n        /* If touching the shoot button */\n\n\n        if (Math.pow(e.changedTouches[i].pageX - _this.shootButton.x, 2) + Math.pow(e.changedTouches[i].pageY - _this.shootButton.y, 2) <= Math.pow(_this.shootButton.radius, 2)) {\n          _this.shoot = true;\n\n          _this.touchingFingers.push(e.changedTouches[i].identifier);\n\n          _this.indexShootButton = _this.touchingFingers.length - 1;\n        }\n        /* if touching the reload button */\n\n\n        if (Math.pow(e.changedTouches[i].pageX - _this.reloadButton.x, 2) + Math.pow(e.changedTouches[i].pageY - _this.reloadButton.y, 2) <= Math.pow(_this.reloadButton.radius, 2)) {\n          _this.reloading = true;\n\n          _this.touchingFingers.push(e.changedTouches[i].identifier);\n\n          _this.indexReloadButton = _this.touchingFingers.length - 1;\n        }\n      }\n    };\n\n    this.handleMovement = function (e) {\n      e.preventDefault();\n\n      for (var i = 0; i < e.changedTouches.length; i++) {\n        /* if clicked */\n        if (e.changedTouches[i].identifier === _this.touchingFingers[_this.indexJoystick] && _this.dragging) {\n          var source = window.mobileCheck() ? e.changedTouches[i] : e;\n          var mx = source.pageX;\n          var my = source.pageY;\n          var angle = Math.atan((my - _this.outterCircle.y) / (mx - _this.outterCircle.x));\n          /* Move freely while in the outer circle */\n\n          if (Math.pow(mx - _this.outterCircle.x, 2) + Math.pow(my - _this.outterCircle.y, 2) <= Math.pow(_this.outterCircle.radius, 2)) {\n            _this.innerCircle.x = mx;\n            _this.innerCircle.y = my;\n          } else {\n            /* When the cursor is outside outer function then predict the position of inner circle\r\n                using sin and cos */\n            var offsetX = void 0;\n            var offsetY = void 0;\n\n            if (mx < _this.outterCircle.x) {\n              offsetX = _this.outterCircle.x - _this.radius * Math.cos(angle) - mx;\n              _this.innerCircle.x = mx + offsetX;\n            } else {\n              offsetX = mx - (_this.outterCircle.x + _this.radius * Math.cos(angle));\n              _this.innerCircle.x = mx - offsetX;\n            }\n\n            if (my < _this.outterCircle.y) {\n              offsetY = _this.outterCircle.y - _this.radius * Math.sign(angle) * Math.sin(angle) - my;\n              _this.innerCircle.y = my + offsetY;\n            } else {\n              offsetY = my - (_this.outterCircle.y + _this.radius * Math.sign(angle) * Math.sin(angle));\n              _this.innerCircle.y = my - offsetY;\n            }\n          }\n          /* Compute the values of movement for characters */\n\n\n          _this.computeAngles(mx - _this.outterCircle.x, _this.outterCircle.y - my, angle);\n        }\n      }\n    };\n\n    this.handleReleased = function (e) {\n      e.preventDefault(); //console.log(` Joystick: ${this.indexJoystick} AND shootButton: ${this.indexShootButton}`);\n\n      for (var i = 0; i < e.changedTouches.length; i++) {\n        console.log(_this.indexJoystick);\n\n        if (_this.touchingFingers[_this.indexJoystick] === e.changedTouches[i].identifier) {\n          _this.dragging = false;\n\n          _this.touchingFingers.splice(_this.indexJoystick, 1);\n\n          _this.indexJoystick = null;\n          /* When released click then return to original position */\n\n          _this.innerCircle.x = _this.position.x;\n          _this.innerCircle.y = _this.position.y;\n          _this.movement = {\n            x: 0,\n            y: 0\n          };\n          /* Stop animation */\n\n          if (_this.character.moveInterval) _this.character.onMovingStop();\n          /* Reset cartesian value */\n\n          _this.cartesianValueOfMovement = {\n            x: 0,\n            y: 0\n          };\n          if (_this.indexReloadButton > _this.indexJoystick) _this.indexReloadButton--;\n          if (_this.indexShootButton > _this.indexJoystick) _this.indexShootButton--;\n        }\n\n        if (_this.touchingFingers[_this.indexShootButton] === e.changedTouches[i].identifier) {\n          _this.touchingFingers.splice(_this.indexShootButton, 1);\n\n          _this.shoot = false;\n          _this.indexShootButton = null;\n          if (_this.indexReloadButton > _this.indexShootButton) _this.indexReloadButton--;\n          if (_this.indexJoystick > _this.indexShootButton) _this.indexJoystick--;\n        }\n\n        if (_this.touchingFingers[_this.indexReloadButton] === e.changedTouches[i].identifier) {\n          _this.touchingFingers.splice(_this.indexReloadButton, 1);\n\n          _this.reloading = false;\n          _this.indexReloadButton = null;\n          if (_this.indexShootButton > _this.indexReloadButton) _this.indexShootButton--;\n          if (_this.indexJoystick > _this.indexReloadButton) _this.indexJoystick--;\n        }\n\n        _this.emitPosition(_this.movement);\n      }\n    };\n\n    /* Drawing canvas */\n    this.canvas = canvas;\n    this.context = canvas.getContext(\"2d\");\n    /* Cos and sin */\n\n    this.movement = {\n      cos: 0,\n      sin: 0\n    };\n    this.angleInDegrees = 0;\n    /* Dragging */\n\n    this.dragging = false;\n    this.shoot = false;\n    this.reloading = false;\n    /* Color and Design */\n\n    this.internalFillColor = internalFillColor || \"rgba(255,255,255,0.8)\";\n    /* Color when pressed */\n\n    this.internalPressedColor = \"rgba(255,255,255,0.4)\";\n    /* Character sprite */\n\n    this.character = character;\n    /* State of the movement */\n\n    this.movement = {\n      x: 0,\n      y: 0\n    };\n    /* Callbacks */\n\n    this.emitPosition = emitPosition;\n    this.emitBullet = emitBullet;\n    this.emitReload = emitReload;\n    /* Cartesian Value of movement */\n\n    this.cartesianValueOfMovement = {\n      x: 0,\n      y: 0,\n      shoot: false\n    };\n    /* Bullet direction */\n\n    this.bulletDir = {\n      x: 0,\n      y: 0\n    };\n    /* Manage indexes of touch events */\n\n    this.indexJoystick = null;\n    this.indexShootButton = null;\n    this.indexReloadButton = null;\n    /* Keep track of fingers touching the screen */\n\n    this.touchingFingers = [];\n    this.addListeners();\n  }\n\n  _createClass(Joystick, [{\n    key: \"drawJoystick\",\n    value: function drawJoystick() {\n      this.context.lineWidth = 2;\n      this.context.font = '15px arial';\n      /* Filling style */\n\n      this.context.fillStyle = this.internalFillColor;\n      /* Draw outer circle */\n\n      this.context.beginPath();\n      this.context.arc(this.outterCircle.x, this.outterCircle.y, this.outterCircle.radius, 0, Math.PI * 2);\n      this.context.stroke();\n      /* Draw inner circle */\n\n      this.context.beginPath();\n      if (this.dragging) this.context.fillStyle = this.internalPressedColor;\n      this.context.arc(this.innerCircle.x, this.innerCircle.y, this.innerCircle.radius, 0, Math.PI * 2);\n      this.context.fill();\n      this.context.stroke();\n      /* Reset Filling style */\n\n      this.context.fillStyle = this.internalFillColor;\n      /* Draw shooting circle */\n\n      this.context.beginPath();\n      if (this.shoot) this.context.fillStyle = this.internalPressedColor;\n      this.context.arc(this.shootButton.x, this.shootButton.y, this.shootButton.radius, 0, Math.PI * 2);\n      this.context.fill();\n      this.context.stroke();\n      /* Draw text under shoot circle */\n\n      this.context.textAlign = 'center';\n      this.context.strokeText('Shoot', this.shootButton.x, this.shootButton.y + 3);\n      /* Reset Filling style */\n\n      this.context.fillStyle = this.internalFillColor;\n      if (this.reloading) this.context.fillStyle = this.internalPressedColor;\n      this.context.beginPath();\n      this.context.arc(this.reloadButton.x, this.reloadButton.y, this.reloadButton.radius, 0, Math.PI * 2);\n      this.context.fill();\n      this.context.stroke();\n      /* Draw text under shoot circle */\n\n      this.context.font = '13px ariel';\n      this.context.strokeText('Reload', this.reloadButton.x, this.reloadButton.y + 3);\n    }\n    /* Event listener to detect if the user is dragging */\n\n  }, {\n    key: \"addListeners\",\n    value: function addListeners() {\n      window.addEventListener('resize', this.resize);\n      this.resize();\n\n      if (window.mobileCheck()) {\n        this.canvas.addEventListener('touchstart', this.handleStart);\n        this.canvas.addEventListener('touchmove', this.handleMovement);\n        this.canvas.addEventListener('touchend', this.handleReleased);\n      } else {\n        this.canvas.addEventListener('mousedown', this.handleStart);\n        this.canvas.addEventListener('mouseup', this.handleReleased);\n        this.canvas.addEventListener('mousemove', this.handleMovement);\n      }\n    }\n    /* Resize joystick -> Responsive */\n\n  }, {\n    key: \"computeAngles\",\n\n    /**\r\n     *  @desc Compute value of character movement based on position of inner circle\r\n     * \r\n     *  @param x - inner circle's X position with regards to outter circle => innerCircleX - outterCircleX\r\n     *  @param y - inner circle's Y position with regards to outter circle => OutterCircleY - innerCircleY\r\n     * \r\n     *  Note: As Y axis is inverted on a canvas, then we must substract from outterCircle\r\n     * \r\n     *  @returns - Object with the value of movement on X and Y\r\n     * */\n    value: function computeAngles(x, y, angle) {\n      var movement = {\n        x: 0,\n        y: 0\n      };\n      /* Calculate the proportion of the distance to be moved */\n\n      var hypotenuse = Math.sqrt(Math.pow(this.outterCircle.x - this.innerCircle.x, 2) + Math.pow(this.innerCircle.y - this.outterCircle.y, 2));\n      /* Get porcentage of movement regards to inner circle's radius */\n\n      var proportionOfMovement = hypotenuse * 100 / this.outterCircle.radius;\n      var degreeAngle = angle * 180 / Math.PI;\n\n      if (x >= 0) {\n        if (y >= 0) {\n          movement = {\n            x: Math.cos(angle),\n            y: Math.sin(angle)\n          };\n          degreeAngle = -degreeAngle;\n        } else {\n          movement = {\n            x: Math.cos(angle),\n            y: Math.sin(angle)\n          };\n          degreeAngle = 360 - degreeAngle;\n        }\n      } else {\n        if (y >= 0) {\n          movement = {\n            x: -Math.cos(angle),\n            y: -Math.sin(angle)\n          };\n          degreeAngle = 180 - degreeAngle;\n        } else {\n          movement = {\n            x: -Math.cos(angle),\n            y: -Math.sin(angle)\n          };\n          degreeAngle -= 180;\n          degreeAngle = -degreeAngle;\n        }\n      }\n      /* Set bullet direction for future shooting */\n\n\n      this.bulletDir = {\n        x: movement.x,\n        y: movement.y\n      };\n      /* apply proportion of movement */\n\n      movement.x *= proportionOfMovement / 100;\n      movement.y *= proportionOfMovement / 100;\n      /* TESTING */\n      //console.log(`${movement.x}, ${movement.y}`);\n\n      this.movement.x = movement.x;\n      this.movement.y = movement.y;\n      this.cartesianValueOfMovement.x = this.movement.x;\n      this.cartesianValueOfMovement.y = -this.movement.y;\n      this.angleInDegrees = degreeAngle;\n    }\n    /* Animate -> emitPosition */\n\n  }, {\n    key: \"animate\",\n    value: function animate() {\n      if (this.movement.x || this.movement.y) {\n        //Calculate character animation\n        var angle = 22.5;\n\n        if ((this.angleInDegrees <= angle || this.angleInDegrees > 337.5) && this.character.currentSprite.y != 1) {\n          this.character.stopMoving();\n          this.character.onMovingRight();\n        }\n\n        if (this.angleInDegrees > angle && this.angleInDegrees <= angle + 45 && this.character.currentSprite.y != 3) {\n          this.character.stopMoving();\n          this.character.onMovingForwardRight();\n        } //Next animation if doesn't match\n\n\n        angle += 45;\n\n        if (this.angleInDegrees > angle && this.angleInDegrees <= angle + 45 && this.character.currentSprite.y != 2) {\n          this.character.stopMoving();\n          this.character.onMovingForward();\n        } //Next animation if doesn't match\n\n\n        angle += 45;\n\n        if (this.angleInDegrees > angle && this.angleInDegrees <= angle + 45 && this.character.currentSprite.y != 3) {\n          this.character.stopMoving();\n          this.character.onMovingForwardLeft();\n        } //Next animation if doesn't match\n\n\n        angle += 45;\n\n        if (this.angleInDegrees > angle && this.angleInDegrees <= angle + 45 && this.character.currentSprite.y != 1) {\n          this.character.stopMoving();\n          this.character.onMovingLeft();\n        } //Next animation if doesn't match\n\n\n        angle += 45;\n\n        if (this.angleInDegrees > angle && this.angleInDegrees <= angle + 45 && this.character.currentSprite.y != 4) {\n          this.character.stopMoving();\n          this.character.onMovingBackwardsLeft();\n        } //Next animation if doesn't match\n\n\n        angle += 45;\n\n        if (this.angleInDegrees > angle && this.angleInDegrees <= angle + 45 && this.character.currentSprite.y != 0) {\n          this.character.stopMoving();\n          this.character.onMovingBackwards();\n        } //Next animation if doesn't match\n\n\n        angle += 45;\n\n        if (this.angleInDegrees > angle && this.angleInDegrees <= angle + 45 && this.character.currentSprite.y != 4) {\n          this.character.stopMoving();\n          this.character.onMovingBackwardsRight();\n        }\n\n        this.emitPosition(this.movement);\n      }\n\n      this.drawJoystick();\n      if (this.shoot) this.createBullet();\n    }\n    /* Create bullet trayectory and sprite of the animation */\n\n  }, {\n    key: \"createBullet\",\n    value: function createBullet() {\n      /* Direction of bullet's trayectory */\n      var dir = {\n        x: 0,\n        y: 0\n      };\n      var spriteY = 0;\n      /* Set trayectory */\n\n      if (this.character.currentSprite.y === 5) dir.x = 1 * this.character.currentSprite.flip;else dir = this.bulletDir;\n      /* Set bullet's sprite position in Y axis */\n\n      if (this.character.currentSprite.y === 1 || this.character.currentSprite.y === 5) spriteY = 2;\n      if (this.character.currentSprite.y === 3) spriteY = 1;\n      if (this.character.currentSprite.y === 4) spriteY = 3;\n      this.emitBullet(dir, spriteY);\n    }\n    /** \r\n     * ===============================\r\n     *      LISTENERS' CALLBACKS\r\n     * ===============================\r\n     * */\n\n  }]);\n\n  return Joystick;\n}();\n\n\n\n//# sourceURL=webpack:///./server/client/js/classes/Joystick.js?");

/***/ }),

/***/ "./server/client/js/classes/Keyboard.js":
/*!**********************************************!*\
  !*** ./server/client/js/classes/Keyboard.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Keyboard; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n *  ===============================\r\n *      Keyboard Controls Class\r\n *  ===============================\r\n */\nvar Keyboard = /*#__PURE__*/function () {\n  function Keyboard(character, emitPosition, emitBullet, emitReload) {\n    _classCallCheck(this, Keyboard);\n\n    /* Character -> in order to determine animations */\n    this.character = character;\n    /* Controls */\n\n    this.controls = {\n      goUp: false,\n      goDown: false,\n      goRight: false,\n      goLeft: false\n    };\n    this.shoot = false;\n    /* Cartesian Value of movement */\n\n    this.cartesianValueOfMovement = {\n      x: 0,\n      y: 0\n    };\n    /* Callbacks */\n\n    this.emitPosition = emitPosition;\n    this.emitBullet = emitBullet;\n    this.emitReload = emitReload;\n    /* Show scores */\n\n    this.showScores = false;\n    this.addListeners();\n  }\n  /* Add keyboard listeners */\n\n\n  _createClass(Keyboard, [{\n    key: \"addListeners\",\n    value: function addListeners() {\n      var _this = this;\n\n      window.addEventListener('keydown', function (e) {\n        e.preventDefault();\n\n        switch (e.key.toLowerCase()) {\n          case 'arrowup':\n            _this.controls.goUp = true;\n            _this.cartesianValueOfMovement.y = _this.controls.goDown ? 0 : 1;\n            break;\n\n          case 'arrowdown':\n            _this.controls.goDown = true;\n            _this.cartesianValueOfMovement.y = _this.controls.goUp ? 0 : -1;\n            break;\n\n          case 'arrowleft':\n            _this.controls.goLeft = true;\n            _this.cartesianValueOfMovement.x = _this.controls.goRight ? 0 : -1;\n            break;\n\n          case 'arrowright':\n            _this.controls.goRight = true;\n            _this.cartesianValueOfMovement.x = _this.controls.goLeft ? 0 : 1;\n            break;\n\n          case 'a':\n            _this.shoot = true;\n            break;\n\n          case 'tab':\n            _this.showScores = true;\n            break;\n\n          case 'r':\n            _this.emitReload();\n\n            break;\n        }\n      });\n      window.addEventListener('keyup', function (e) {\n        e.preventDefault();\n\n        switch (e.key.toLowerCase()) {\n          case 'arrowup':\n            _this.character.stopMoving();\n\n            _this.controls.goUp = false;\n            _this.cartesianValueOfMovement.y = _this.controls.goDown ? -1 : 0;\n            break;\n\n          case 'arrowdown':\n            _this.character.stopMoving();\n\n            _this.controls.goDown = false;\n            _this.cartesianValueOfMovement.y = _this.controls.goUp ? 1 : 0;\n            break;\n\n          case 'arrowleft':\n            _this.character.stopMoving();\n\n            _this.controls.goLeft = false;\n            _this.cartesianValueOfMovement.x = _this.controls.goRight ? 1 : 0;\n            break;\n\n          case 'arrowright':\n            _this.character.stopMoving();\n\n            _this.controls.goRight = false;\n            _this.cartesianValueOfMovement.x = _this.controls.goLeft ? -1 : 0;\n            break;\n\n          case 'a':\n            _this.shoot = false;\n            break;\n\n          case 'tab':\n            _this.showScores = false;\n            document.getElementById('site-individual-scores').style.display = 'none';\n            break;\n        }\n\n        _this.emitPosition({\n          x: 0,\n          y: 0\n        });\n      });\n    }\n    /**\r\n     * ==========================\r\n     *      Animate Character\r\n     * ==========================\r\n     */\n\n    /* Animating local character using data from server */\n\n  }, {\n    key: \"animate\",\n    value: function animate() {\n      var movement = {\n        x: 0,\n        y: 0\n      };\n\n      if (this.controls.goUp && this.controls.goLeft) {\n        if (this.character.currentSprite.y != 3) {\n          this.character.stopMoving();\n          this.character.onMovingForwardLeft();\n        }\n      }\n\n      if (this.controls.goUp && this.controls.goRight) {\n        if (this.character.currentSprite.y != 3) {\n          this.character.stopMoving();\n          this.character.onMovingForwardRight();\n        }\n      }\n\n      if (this.controls.goDown && this.controls.goRight) {\n        if (this.character.currentSprite.y != 4) {\n          this.character.stopMoving();\n          this.character.onMovingBackwardsRight();\n        }\n      }\n\n      if (this.controls.goDown && this.controls.goLeft) {\n        if (this.character.currentSprite.y != 4) {\n          this.character.stopMoving();\n          this.character.onMovingBackwardsLeft();\n        }\n      }\n\n      if (this.controls.goUp) {\n        movement.y = this.controls.goDown ? 0 : -1;\n        if (!this.character.moveInterval) this.character.onMovingForward();\n      }\n\n      if (this.controls.goDown) {\n        movement.y = this.controls.goUp ? 0 : 1;\n        if (!this.character.moveInterval) this.character.onMovingBackwards();\n      }\n\n      if (this.controls.goRight) {\n        movement.x = this.controls.goLeft ? 0 : 1;\n        if (!this.character.moveInterval) this.character.onMovingRight();\n      }\n\n      if (this.controls.goLeft) {\n        movement.x = this.controls.goRight ? 0 : -1;\n        if (!this.character.moveInterval) this.character.onMovingLeft();\n      }\n\n      if (this.shoot) this.createBullet();\n      if (movement.x !== 0 || movement.y !== 0) this.emitPosition(movement);else if (this.character.currentSprite.y !== 5) {\n        this.character.onMovingStop();\n        this.emitPosition(movement);\n      }\n    }\n  }, {\n    key: \"createBullet\",\n    value: function createBullet() {\n      /* Position on bullet sprite (Y) */\n      var spriteY = 0;\n      /* Direction of bullet */\n\n      var dir = {\n        x: 0,\n        y: 0\n      };\n\n      switch (this.character.currentSprite.y) {\n        case 0:\n          dir.x = 0;\n          dir.y = 1;\n          spriteY = 0;\n          break;\n\n        case 1:\n          dir.y = 0;\n          dir.x = 1 * this.character.currentSprite.flip;\n          spriteY = 2;\n          break;\n\n        case 2:\n          dir.x = 0;\n          dir.y = -1;\n          spriteY = 0;\n          break;\n\n        case 3:\n          dir.y = -Math.sin(Math.PI / 4);\n          dir.x = Math.sin(Math.PI / 4) * this.character.currentSprite.flip;\n          spriteY = 1;\n          break;\n\n        case 4:\n          dir.y = Math.sin(Math.PI / 4);\n          dir.x = Math.sin(Math.PI / 4) * this.character.currentSprite.flip;\n          spriteY = 3;\n          break;\n\n        case 5:\n          dir.x = 1 * this.character.currentSprite.flip;\n          dir.y = 0;\n          spriteY = 2;\n          break;\n      }\n\n      this.emitBullet(dir, spriteY);\n    }\n  }]);\n\n  return Keyboard;\n}();\n\n\n\n//# sourceURL=webpack:///./server/client/js/classes/Keyboard.js?");

/***/ }),

/***/ "./server/client/js/classes/Online.js":
/*!********************************************!*\
  !*** ./server/client/js/classes/Online.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Online; });\n/* harmony import */ var _Engine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Engine.js */ \"./server/client/js/classes/Engine.js\");\n/* harmony import */ var _OnlineChat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OnlineChat.js */ \"./server/client/js/classes/OnlineChat.js\");\n/* harmony import */ var _Joystick_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Joystick.js */ \"./server/client/js/classes/Joystick.js\");\n/* harmony import */ var _Keyboard_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Keyboard.js */ \"./server/client/js/classes/Keyboard.js\");\n/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./State.js */ \"./server/client/js/classes/State.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n/**\r\n * ================================\r\n *      ONLINE GAME ENGINE\r\n * ================================\r\n */\n\nvar Online = /*#__PURE__*/function (_Engine) {\n  _inherits(Online, _Engine);\n\n  var _super = _createSuper(Online);\n\n  function Online(map, colissionMatrix, shadowMatrix, tileSet, canvas, socket, playerID, server, skin, name, game) {\n    var _this;\n\n    _classCallCheck(this, Online);\n\n    _this = _super.call(this, map, colissionMatrix, shadowMatrix, tileSet, canvas, skin);\n\n    _this.render = function (timeSinceLastFrame) {\n      _this.context.clearRect(0, 0, _this.canvas.width, _this.canvas.height);\n\n      _this.interpolate();\n\n      if (_this.playerStats) _this.calculateLocalMap();\n\n      _this.calculateOffset();\n\n      _this.drawMap();\n\n      _this.drawShadows();\n\n      _this.drawObjects();\n\n      _this.drawBonusKits();\n\n      if (_this.state.flags) _this.drawFlags();\n\n      _this.drawBullets();\n\n      _this.drawOtherPlayers();\n\n      _this.showScoresTable();\n\n      _this.controls.animate();\n\n      _this.context.font = '16px cursive';\n      _this.context.fillStyle = 'black';\n\n      if (Date.now() - _this.lastStillUpdate >= _this.character.animationSpeed) {\n        _this.staticAnimation.x++;\n        if (_this.staticAnimation.x === 3) _this.staticAnimation.x = 0;\n        _this.lastStillUpdate = Date.now();\n      } //this.drawCharacter()\n\n\n      _this.context.fillStyle = \"black\";\n\n      _this.context.fillText(\"Delay: \".concat(_this.renderDelay), _this.screenTiles.x * _this.tile.height - 100, 50);\n\n      _this.context.fillText(\"Net: \".concat(_this.latency, \"ms\"), _this.screenTiles.x * _this.tile.height - 100, 70);\n\n      if (_this.reloading || _this.currentAmmo === 0) {\n        _this.context.textAlign = 'center';\n\n        _this.context.fillText('Reloading...', _this.screenTiles.x * _this.tile.width / 2, _this.canvas.height - 10);\n      }\n\n      requestAnimationFrame(function () {\n        /* FPS Counter */\n        var now = new Date();\n        timeSinceLastFrame = _this.lastFrameTime ? now - _this.lastFrameTime : 0;\n\n        _this.render(timeSinceLastFrame);\n\n        _this.lastFrameTime = now;\n        _this.FPS = Math.floor(1 / (timeSinceLastFrame / 1000));\n      });\n    };\n\n    _this.emitPlayerPosition = function (movement) {\n      _this.socketIO.emit('movement', {\n        movement: movement,\n        cartisianMovement: _this.controls.cartesianValueOfMovement,\n        character: {\n          currentSprite: _this.character.currentSprite\n        }\n      });\n    };\n\n    _this.bubbleSort = function () {\n      var players = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.state.players;\n      var playersArr = Object.values(Object.fromEntries(Object.entries(players).map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            id = _ref2[0],\n            player = _ref2[1];\n\n        return [id, {\n          kills: player.kills,\n          deaths: player.deaths,\n          name: player.playerName,\n          id: id\n        }];\n      })));\n      var swapped;\n\n      do {\n        swapped = false;\n\n        for (var i = 0; i < playersArr.length - 1; i++) {\n          if (playersArr[i].kills < playersArr[i + 1].kills) {\n            var tmp = playersArr[i];\n            playersArr[i] = playersArr[i + 1];\n            playersArr[i + 1] = tmp;\n            swapped = true;\n          }\n        }\n      } while (swapped);\n\n      return playersArr;\n    };\n\n    _this.emitReload = function () {\n      if (_this.currentAmmo !== _this.playerAmmunition && !_this.reloading) {\n        _this.reloading = true;\n\n        _this.socketIO.emit('reload weapon');\n      }\n    };\n\n    _this.controls = window.mobileCheck() ? new _Joystick_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](_this.canvas, _this.character, _this.emitPlayerPosition, _this.triggerShooting) : new _Keyboard_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_this.character, _this.emitPlayerPosition, _this.triggerShooting, _this.emitReload, _this.playerStats);\n    _this.name = name;\n    /* Online attributes recevied from the sever */\n\n    _this.playerID = playerID;\n    _this.serverDelay = null;\n    _this.socketIO = socket;\n    /* online team */\n\n    _this.team = game.mode ? game.team : undefined;\n    /* game mode */\n\n    _this.mode = game.mode;\n    /* Create a chat room */\n\n    _this.chat = new _OnlineChat_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](_this.socketIO);\n    /* Add to emit => the skin */\n\n    _this.socketIO.emit('New Player', {\n      name: _this.name,\n      skin: _this.skin,\n      character: _this.character.currentSprite,\n      game: game\n    });\n\n    _this.state = null;\n    _this.server = server;\n    /* CALCULATE network speed */\n\n    _this.latency = 0;\n    /* Skins array of images */\n\n    _this.onlineSkins = {};\n    /* Check change on cartesian value of movement */\n\n    _this.cartesianChange = {\n      x: false,\n      y: false\n    };\n    /**\r\n     *  =============================\r\n     *        INTERPOLATE STATE\r\n     *  =============================\r\n     */\n\n    _this.renderDelay = 0;\n    _this.gameUpdates = new _State_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](function (delay) {\n      return _this.renderDelay = delay;\n    });\n    /* SOCKET LISTENERS */\n\n    _this.socketIO.on('state', function (data) {\n      _this.gameUpdates.processGameUpdate(data);\n\n      _this.serverDelay = Date.now() - data.serverTime;\n    });\n    /* When new players enter the lobby, they must load other users skins and default info about the skin selected */\n\n\n    _this.socketIO.on('Load Skins, ammunition and sounds', function (_ref3) {\n      var skins = _ref3.skins,\n          ids = _ref3.ids;\n      skins.srcArray.forEach(function (value) {\n        if (value != _this.skin) {\n          _this.loadServerSkin(value);\n        }\n      });\n      _this.playerAmmunition = skins.characterInfo.bullets;\n      _this.currentAmmo = _this.playerAmmunition;\n      _this.shootingDelay = skins.characterInfo.shootingDelay;\n      _this.bulletsHTMLElement.innerText = \"\".concat(_this.currentAmmo, \"/\").concat(_this.playerAmmunition);\n      /* Load a footstep audio for every player already in the room */\n\n      ids.map(function (id) {\n        _this.sounds.footsteps[id] = {\n          sound: new Audio('../assets/sounds/footstep.mp3')\n        };\n      });\n    });\n    /* when a new player enters, other people must load their skin */\n\n\n    _this.socketIO.on('Load New Skin', function (_ref4) {\n      var src = _ref4.src,\n          id = _ref4.id;\n      var element = _this.onlineSkins[src];\n      if (!element && src != _this.skin) _this.loadServerSkin(src);\n      var availableSlot = Object.keys(_this.sounds.footsteps).find(function (idPlayer) {\n        return _this.sounds.footsteps[idPlayer].free;\n      });\n\n      if (availableSlot) {\n        _this.sounds.footsteps[id] = {\n          sound: _this.sounds.footsteps[availableSlot].sound\n        };\n        delete _this.sounds.footsteps[availableSlot];\n      } else _this.sounds.footsteps[id] = {\n        sound: new Audio('../assets/sounds/footstep.mp3')\n      };\n    });\n    /* When a player's been disconnected set its footstep variable as free, so that new players can used it, without needing to load the audio again */\n\n\n    _this.socketIO.on('Player Disconnected', function (id) {\n      if (_this.sounds.footsteps[id]) _this.sounds.footsteps[id].free = true;\n      console.log(\"Someone disconnected from the lobby\");\n    });\n    /* When the score changes */\n\n\n    _this.socketIO.on('New leaderboard', function (data) {\n      var positions = ['trophy', 'medal', 'award'];\n      var score = document.getElementById('scores');\n      score.innerHTML = '';\n      data.map(function (elem, index) {\n        var text = document.createElement('p');\n        if (elem.id === _this.playerID) text.style.color = '#f0565e';\n        var scoreText = \"<i class=\\\"fas fa-\".concat(positions[index], \"\\\"></i>.\").concat(elem.name, \": \").concat(elem.score);\n        text.innerHTML = scoreText;\n        score.appendChild(text);\n      });\n    });\n    /* Scores from a team based lobby */\n\n\n    _this.socketIO.on('New teams leaderboard', function (data) {\n      document.getElementById('fbi-score').innerHTML = data.blueTeam;\n      document.getElementById('gambinos-score').innerHTML = data.redTeam;\n    });\n\n    _this.socketIO.on('pong', function (ms) {\n      _this.latency = ms;\n    });\n    /* Play sound effect */\n\n\n    _this.socketIO.on('Bullet sound', function (_ref5) {\n      var bullet = _ref5.bullet,\n          sound = _ref5.sound;\n\n      if (_this.playerStats) {\n        var distanceFromGunshot = Math.floor(Math.sqrt(Math.pow(_this.playerStats.posX - bullet.x, 2) + Math.pow(_this.playerStats.posY - bullet.y, 2)));\n\n        if (distanceFromGunshot <= _this.soundWaves.bullets && !window.mobileCheck()) {\n          if (!_this.sounds[sound].paused) _this.sounds[sound].currentTime = 0;\n          _this.sounds[sound].volume = (1 - distanceFromGunshot / _this.soundWaves.bullets) / 2;\n\n          _this.sounds[sound].play();\n        }\n      }\n    });\n    /** \r\n     *  ===========================================\r\n     *      SOUND EFFECTS WHEN PICKING A BONUS\r\n     *  ===========================================\r\n    */\n\n\n    _this.socketIO.on('Capture medicalKit', function () {\n      _this.sounds.healing.play();\n    });\n\n    _this.socketIO.on('Capture bulletKit', function () {\n      _this.sounds.reload.play();\n    });\n    /* Still players animation */\n\n\n    _this.lastStillUpdate = Date.now();\n    /* Add color to score */\n\n    if (_this.team === 0) document.getElementById('fbi-score').style.color = 'rgb(240, 86, 94)';else if (_this.team === 1) document.getElementById('gambinos-score').style.color = 'rgb(240, 86, 94)';\n    return _this;\n  }\n  /**\r\n   * ==========================\r\n   *      RENDER FUNCTION\r\n   * ==========================\r\n   * \r\n   * Called once sprites are loaded by the engine\r\n   */\n\n\n  _createClass(Online, [{\n    key: \"interpolate\",\n\n    /** \r\n    *  ============================\r\n    *       INTERPOLATE STATE\r\n    *  ============================\r\n    */\n    value: function interpolate() {\n      this.state = this.gameUpdates.getCurrentState();\n      this.updateState();\n    }\n    /* Send data back to the server */\n\n  }, {\n    key: \"calculateLocalMap\",\n\n    /* Calculates the position of the map in the browser => startX and startY */\n    value: function calculateLocalMap() {\n      var serverWidth = this.transformServerMagnitudesX(this.playerStats.posX);\n      var serverHeight = this.transformServerMagnitudesY(this.playerStats.posY);\n      /* X axis smoothness */\n\n      if (this.cameraSmoothness.offsetX < this.cameraSmoothness.limitX && this.cameraSmoothness.offsetX > -this.cameraSmoothness.limitX && this.playerStats.cartesianValueOfMovement.x) {\n        this.cameraSmoothness.velX = this.cameraSmoothness.velX > 1.8 ? 2 : this.cameraSmoothness.velX / this.cameraSmoothness.friction;\n        this.cameraSmoothness.offsetX += this.cameraSmoothness.velX * this.playerStats.cartesianValueOfMovement.x;\n      } else if ((this.playerStats.cartesianValueOfMovement.x > 0 && this.cameraSmoothness.offsetX < 0 || this.playerStats.cartesianValueOfMovement.x < 0 && this.cameraSmoothness.offsetX > 0 || this.playerStats.cartesianValueOfMovement.x === 0) && this.cameraSmoothness.offsetX !== 0) {\n        this.cameraSmoothness.velX = this.cameraSmoothness.velX <= .4 ? .4 : this.cameraSmoothness.velX * this.cameraSmoothness.friction;\n        if (this.cameraSmoothness.offsetX < 0) this.cameraSmoothness.offsetX += this.cameraSmoothness.velX;else this.cameraSmoothness.offsetX -= this.cameraSmoothness.velX;\n      }\n      /* Y axis smootheness */\n\n\n      if (this.cameraSmoothness.offsetY < this.cameraSmoothness.limitX && this.cameraSmoothness.offsetY > -this.cameraSmoothness.limitX && this.playerStats.cartesianValueOfMovement.y) {\n        this.cameraSmoothness.velY = this.cameraSmoothness.velY > 1.7 ? 2 : this.cameraSmoothness.velY / this.cameraSmoothness.friction;\n        this.cameraSmoothness.offsetY += this.cameraSmoothness.velY * (this.playerStats.cartesianValueOfMovement.y * -1);\n      } else if ((this.playerStats.cartesianValueOfMovement.y < 0 && this.cameraSmoothness.offsetY < 0 || this.playerStats.cartesianValueOfMovement.y > 0 && this.cameraSmoothness.offsetY > 0 || this.playerStats.cartesianValueOfMovement.y === 0) && this.cameraSmoothness.offsetY !== 0) {\n        this.cameraSmoothness.velY = this.cameraSmoothness.velY <= .4 ? .4 : this.cameraSmoothness.velY * this.cameraSmoothness.friction;\n        if (this.cameraSmoothness.offsetY < 0) this.cameraSmoothness.offsetY += this.cameraSmoothness.velY;else this.cameraSmoothness.offsetY -= this.cameraSmoothness.velY;\n      } //console.log(`x: ${this.cameraSmoothness.offsetX}, y: ${this.cameraSmoothness.offsetY}`)\n\n      /* Offset smooth camera */\n\n\n      this.tileMap.startX = this.screenTiles.x * this.tile.width / 2 - this.tile.width / 2 - serverWidth + this.cameraSmoothness.offsetX;\n      this.tileMap.startY = this.screenTiles.y * this.tile.height / 2 - this.tile.height / 2 - serverHeight + this.cameraSmoothness.offsetY;\n    }\n    /**\r\n     *  ==========================\r\n     *      DRAW ONLINE PLAYERS \r\n     *  ==========================\r\n     */\n\n    /* Loops server players and calls the drawOnlineCharacter to draw each player with the data from the socket */\n\n  }, {\n    key: \"drawOtherPlayers\",\n    value: function drawOtherPlayers() {\n      if (Array.isArray(this.state.players)) {\n        var colors = this.state.players[0][this.playerID] ? [this.colors.ally, this.colors.enemy] : [this.colors.enemy, this.colors.ally];\n        this.drawPlayers(this.state.players[0], colors[0]);\n        this.drawPlayers(this.state.players[1], colors[1]);\n      } else {\n        this.drawPlayers(this.state.players);\n      }\n    }\n  }, {\n    key: \"drawPlayers\",\n    value: function drawPlayers(players) {\n      var lifeColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.colors.enemy;\n      var quitePlayers = false;\n\n      for (var playerID in players) {\n        var characterX = this.transformServerMagnitudesX(players[playerID].posX) + this.tileMap.startX;\n        var characterY = this.transformServerMagnitudesY(players[playerID].posY) + this.tileMap.startY;\n        /* If the character is outside the screen don't draw it */\n\n        if (characterX + this.tile.width >= 0 && characterX < this.screenTiles.x * this.tile.width && characterY + this.tile.height >= 0 && characterY < this.screenTiles.y * this.tile.height && players[playerID].character) {\n          var skin = players[playerID].skin == this.skin ? this.character.spriteSheet.img : this.onlineSkins[players[playerID].skin];\n          /* Check if any player is still */\n\n          if (players[playerID].still && players[playerID].life > 0) quitePlayers = true;\n\n          if (players[playerID].character.currentSprite.x % 2 == 1 && !players[playerID].still && !window.mobileCheck()) {\n            var distanceFromFootstep = Math.floor(Math.sqrt(Math.pow(this.playerStats.posX - players[playerID].posX, 2) + Math.pow(this.playerStats.posY - players[playerID].posY, 2)));\n\n            if (distanceFromFootstep <= this.soundWaves.footsteps && !window.mobileCheck()) {\n              this.sounds.footsteps[playerID].sound.volume = (1 - distanceFromFootstep / this.soundWaves.footsteps) / 10;\n              this.sounds.footsteps[playerID].sound.play();\n            }\n          }\n\n          if (skin) {\n            var color = playerID === this.playerID ? this.colors.self : lifeColor;\n            this.drawLife(characterX, characterY - 6, players[playerID].life, color);\n            var character = {\n              flip: players[playerID].character.currentSprite.y === 0 || players[playerID].character.currentSprite.y === 2 ? 1 : players[playerID].character.currentSprite.flip,\n              y: players[playerID].shooting && players[playerID].life > 0 ? players[playerID].character.currentSprite.y + 6 : players[playerID].character.currentSprite.y,\n              x: players[playerID].still && players[playerID].life > 0 ? this.staticAnimation.x : players[playerID].character.currentSprite.x\n            };\n            this.drawOnlineCharacter({\n              posX: characterX,\n              posY: characterY\n            }, character, skin, players[playerID].playerName);\n          }\n        }\n      }\n\n      return quitePlayers;\n    }\n    /* Draws online players from server's data */\n\n  }, {\n    key: \"drawOnlineCharacter\",\n    value: function drawOnlineCharacter(player, onlineCharacter, skin, name) {\n      this.context.textAlign = 'center';\n      this.context.fillStyle = 'black';\n      this.context.fillText(name, player.posX + this.tile.width / 2, player.posY - 10);\n      this.context.save();\n      this.context.scale(onlineCharacter.flip, 1);\n      var posX = onlineCharacter.flip === 1 ? player.posX : player.posX * onlineCharacter.flip - this.tile.width;\n      this.context.drawImage(skin, onlineCharacter.x * this.character.spriteSheet.width, onlineCharacter.y * this.character.spriteSheet.height, this.character.spriteSheet.width, this.character.spriteSheet.height, posX, player.posY, this.tile.width, this.tile.height);\n      this.context.restore();\n    }\n    /* Uses the rule of three mathematic formula to transform values from the server */\n\n  }, {\n    key: \"transformServerMagnitudesX\",\n    value: function transformServerMagnitudesX(serverValue) {\n      return this.tileMap.width * serverValue / this.server.width;\n    }\n  }, {\n    key: \"transformServerMagnitudesY\",\n    value: function transformServerMagnitudesY(serverValue) {\n      return this.tileMap.height * serverValue / this.server.height;\n    }\n    /* Load new skin from the server */\n\n  }, {\n    key: \"loadServerSkin\",\n    value: function loadServerSkin(src) {\n      var characterSkin = new Image();\n      characterSkin.src = \"../assets/characters/\".concat(src, \".png\");\n      this.onlineSkins[src] = characterSkin;\n    }\n    /** \r\n     * =========================\r\n     *      Bullet Mechanics\r\n     * =========================\r\n    */\n\n    /* Draw bullets contain on the server */\n\n  }, {\n    key: \"drawBullets\",\n    value: function drawBullets() {\n      var _this2 = this;\n\n      if (this.state.bullets.length > 0) {\n        this.state.bullets.map(function (element) {\n          var bulletX = _this2.transformServerMagnitudesX(element.posX) + _this2.tileMap.startX;\n\n          var bulletY = _this2.transformServerMagnitudesY(element.posY) + _this2.tileMap.startY;\n\n          if (bulletX >= 0 && bulletX < _this2.screenTiles.x * _this2.tile.width && bulletY + _this2.bulletSprite.width >= 0 && bulletY < _this2.screenTiles.y * _this2.tile.height) {\n            _this2.context.save();\n\n            _this2.context.scale(element.flip, 1);\n\n            var posX = element.flip === 1 ? bulletX : bulletX * element.flip;\n            var spritePosX = 0;\n            var spritePosY = element.spriteY * 16;\n\n            if (element.spriteY === 0) {\n              spritePosX += 5;\n              posX -= _this2.canvas.width * .005;\n            } else if (element.spriteY === 1) posX -= _this2.canvas.width * .015;else if (element.spriteY === 2) bulletY -= _this2.canvas.width * .01;\n\n            _this2.context.drawImage(_this2.bulletSprite.img, spritePosX, spritePosY, 16, 16, posX, bulletY, _this2.bulletSprite.width, _this2.bulletSprite.height);\n\n            _this2.context.restore();\n            /* Draw actual trayectory of the bullet */\n\n            /*\r\n            this.context.beginPath()\r\n            this.context.arc(this.transformServerMagnitudesX(element.posX)+this.tileMap.startX, this.transformServerMagnitudesY(element.posY) +this.tileMap.startY, 5, 0, 2 * Math.PI)\r\n            this.context.fill()\r\n            */\n\n          }\n        });\n      }\n    }\n    /**\r\n     *  =========================\r\n     *        DRAW BONUS KITS\r\n     *  =========================\r\n     */\n\n  }, {\n    key: \"drawBonusKits\",\n    value: function drawBonusKits() {\n      var _this3 = this;\n\n      var drawKit = function drawKit(img, location) {\n        _this3.context.drawImage(img, location.x, location.y, _this3.kits.width, _this3.kits.height);\n      };\n\n      var bulletKitPos;\n      var medicalKitPos;\n      /* calculate local position of bulletKit */\n\n      if (this.state.bonusKits.bulletKit) {\n        bulletKitPos = {\n          x: this.transformServerMagnitudesX(this.state.bonusKits.bulletKit.x) + this.tileMap.startX,\n          y: this.transformServerMagnitudesY(this.state.bonusKits.bulletKit.y) + this.tileMap.startY\n        };\n      }\n      /* calculate local position of medicalKit */\n\n\n      if (this.state.bonusKits.medicalKit) {\n        medicalKitPos = {\n          x: this.transformServerMagnitudesX(this.state.bonusKits.medicalKit.x) + this.tileMap.startX,\n          y: this.transformServerMagnitudesY(this.state.bonusKits.medicalKit.y) + this.tileMap.startY\n        };\n      }\n\n      if (bulletKitPos && bulletKitPos.x + this.tile.width >= 0 && bulletKitPos.x < this.screenTiles.x * this.tile.width && bulletKitPos.y + this.tile.height >= 0 && bulletKitPos.y < this.screenTiles.y * this.tile.height) drawKit(this.kits.bullets, bulletKitPos);\n      if (medicalKitPos && medicalKitPos.x + this.tile.width >= 0 && medicalKitPos.x < this.screenTiles.x * this.tile.width && medicalKitPos.y + this.tile.height >= 0 && medicalKitPos.y < this.screenTiles.y * this.tile.height) drawKit(this.kits.medical, medicalKitPos);\n    }\n    /**\r\n     *  ============================\r\n     *      DRAW FLAGS ON CANVAS\r\n     *  ============================\r\n     */\n\n  }, {\n    key: \"drawFlags\",\n    value: function drawFlags() {\n      /* Pick flag color depending on the team */\n      var flags = this.state.players[0][this.playerID] ? [this.flags.blue, this.flags.red, this.pointers.blue, this.pointers.red] : [this.flags.red, this.flags.blue, this.pointers.red, this.pointers.blue];\n      /* Server blue flag */\n\n      var serverBlueFlag = {\n        x: this.transformServerMagnitudesX(this.state.flags[0].pos.x) + this.tileMap.startX,\n        y: this.transformServerMagnitudesY(this.state.flags[0].pos.y) + this.tileMap.startY\n      };\n      var serverRedFlag = {\n        x: this.transformServerMagnitudesX(this.state.flags[1].pos.x) + this.tileMap.startX,\n        y: this.transformServerMagnitudesY(this.state.flags[1].pos.y) + this.tileMap.startY\n      };\n      var carrierBlue = this.state.flags[0].carrier ? this.state.players[1][this.state.flags[0].carrier] : false;\n      var carrierRed = this.state.flags[1].carrier ? this.state.players[0][this.state.flags[1].carrier] : false;\n      /* render the flags onto the canvas */\n\n      this.renderFlag(flags[0], serverBlueFlag, carrierBlue, flags[2]);\n      this.renderFlag(flags[1], serverRedFlag, carrierRed, flags[3]);\n    }\n    /* Show scores table */\n\n  }, {\n    key: \"showScoresTable\",\n    value: function showScoresTable() {\n      if (this.controls.showScores && this.state) {\n        if (!this.mode) {\n          var sortedPlayers = this.bubbleSort();\n          this.displayScoreRows(sortedPlayers, document.getElementById('site-scores-data'));\n        } else {\n          /* decide team colors and diplay */\n          var sortedBlueTeam = this.bubbleSort(this.state.players[0]);\n          var sortedRedTeam = this.bubbleSort(this.state.players[1]);\n          var teams = this.state.players[0][this.playerID] ? [sortedBlueTeam, sortedRedTeam] : [sortedRedTeam, sortedBlueTeam];\n          this.displayScoreRows(teams[0], document.getElementById('scores-team-blue'));\n          this.displayScoreRows(teams[1], document.getElementById('scores-team-red'));\n        }\n      }\n    }\n    /* Display every row on the score table */\n\n  }, {\n    key: \"displayScoreRows\",\n    value: function displayScoreRows(players, table) {\n      var _this4 = this;\n\n      /* Html element previously set to show this table */\n      table.innerHTML = \"\";\n      var scoreTable = document.getElementById('site-individual-scores');\n      players.map(function (player) {\n        /* Parent div */\n        var div = document.createElement('div');\n        var classes = 'table-row clearfix';\n        if (player.id === _this4.playerID) classes += \" current-player\";\n        div.classList = classes;\n        /* Create HTML element to display username */\n\n        var usernameDiv = document.createElement('div');\n        usernameDiv.classList = \"entry\";\n        var username = document.createElement('p');\n        username.innerHTML = player.name;\n        usernameDiv.append(username);\n        /*  HTML Element to display number of kills */\n\n        var killsDiv = document.createElement('div');\n        killsDiv.classList = \"entry\";\n        var kills = document.createElement('p');\n        kills.innerHTML = player.kills;\n        killsDiv.append(kills);\n        /* HTML element to display number of deaths */\n\n        var deathsDiv = document.createElement('div');\n        deathsDiv.classList = \"entry\";\n        var deaths = document.createElement('p');\n        deaths.innerHTML = player.deaths;\n        deathsDiv.append(deaths);\n        div.append(usernameDiv);\n        div.append(killsDiv);\n        div.append(deathsDiv);\n        table.append(div);\n      });\n\n      if (scoreTable.style.display === 'none' || !scoreTable.style.display) {\n        scoreTable.style.display = 'block';\n      }\n    }\n    /* Bubble sort for sorting score's table */\n\n  }, {\n    key: \"renderFlag\",\n    value: function renderFlag(img, pos, carrier, pointer) {\n      /* Draw flag if on screen */\n      if (pos && pos.x + this.tile.width >= 0 && pos.x < this.screenTiles.x * this.tile.width && pos.y + this.tile.height >= 0 && pos.y < this.screenTiles.y * this.tile.height) {\n        var flip = carrier ? carrier.character.currentSprite.flip * -1 : 1;\n        var posX = flip === 1 ? pos.x : pos.x * flip - this.tile.width;\n        this.context.save();\n        this.context.scale(flip, 1);\n        this.context.drawImage(img, this.staticAnimation.x * this.character.spriteSheet.width, 0, this.character.spriteSheet.width, this.character.spriteSheet.height, posX, pos.y, this.tile.width, this.tile.height);\n      } else {\n        /* Draw indicator of flag's position */\n        var _posX = pos.x;\n        var posY = pos.y;\n        if (pos.x <= 0) _posX = 0;else if (pos.x >= this.screenTiles.x * this.tile.width - this.tile.width / 2) _posX = this.screenTiles.x * this.tile.width - this.tile.width / 2;\n        if (pos.y <= 0) posY = 0;else if (pos.y >= this.screenTiles.y * this.tile.height - this.tile.height / 2) posY = this.screenTiles.y * this.tile.height - this.tile.height / 2; //console.log(`${posX}, ${posY}`);    \n\n        this.context.drawImage(pointer, _posX, posY, this.tile.width / 2, this.tile.height / 2);\n      }\n\n      this.context.restore();\n    }\n    /** Update state */\n\n  }, {\n    key: \"updateState\",\n    value: function updateState() {\n      this.playerStats = Array.isArray(this.state.players) ? this.state.players[0][this.playerID] || this.state.players[1][this.playerID] : this.state.players[this.playerID];\n\n      if (this.playerStats) {\n        if (this.currentAmmo !== this.playerStats.bulletsCharger) {\n          this.currentAmmo = this.playerStats.currentAmmo;\n          this.bulletsHTMLElement.innerText = \"\".concat(this.currentAmmo, \"/\").concat(this.playerAmmunition);\n        }\n        /* Check if the player is reloading */\n\n\n        this.reloading = this.playerStats.reloading;\n      }\n    }\n    /* Emit bullet to server */\n\n  }, {\n    key: \"emitBullet\",\n    value: function emitBullet(dir, spriteY) {\n      this.socketIO.emit('shoot', {\n        bullet: {\n          dir: dir,\n          spriteY: spriteY\n        },\n        shootTime: Date.now() - this.serverDelay\n      });\n    }\n  }]);\n\n  return Online;\n}(_Engine_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n\n//# sourceURL=webpack:///./server/client/js/classes/Online.js?");

/***/ }),

/***/ "./server/client/js/classes/OnlineChat.js":
/*!************************************************!*\
  !*** ./server/client/js/classes/OnlineChat.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return OnlineChat; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n     * =================================\r\n     *      Online Chat Manager\r\n     * =================================\r\n     */\nvar OnlineChat = /*#__PURE__*/function () {\n  function OnlineChat(socketIO) {\n    _classCallCheck(this, OnlineChat);\n\n    /* Initialize Parent's socket */\n    this.socketIO = socketIO;\n    /* Default it will be false */\n\n    this.active = false;\n    /* Get chat settings */\n\n    this.inputChat = document.getElementById('chat-message');\n    this.messages = document.getElementById('chatMessages');\n    /* Add controls */\n\n    this.addChatControls();\n    this.addSocketListeners();\n  }\n  /** \r\n   * =============================\r\n   *      add Listeners\r\n   * =============================\r\n  */\n\n\n  _createClass(OnlineChat, [{\n    key: \"addChatControls\",\n    value: function addChatControls() {\n      var _this = this;\n\n      this.inputChat.onfocus = function () {\n        return _this.active = true;\n      };\n\n      this.inputChat.onblur = function () {\n        return _this.active = false;\n      };\n\n      window.addEventListener('keydown', function (e) {\n        if (e.key.toLowerCase() == 'enter') {\n          if (_this.active) {\n            _this.inputChat.blur();\n\n            _this.emitMessage();\n          } else _this.inputChat.focus();\n        }\n      });\n    }\n  }, {\n    key: \"addSocketListeners\",\n    value: function addSocketListeners() {\n      var _this2 = this;\n\n      this.socketIO.on('new Chat Message', function (data) {\n        /* Create message HTML node */\n        var message = document.createElement('p');\n        message.className = 'single-comment';\n        message.innerHTML = \"<span> \".concat(data.name, \"</span>: \").concat(data.text);\n\n        _this2.messages.append(message);\n        /* Scroll to the new message */\n\n\n        _this2.messages.scroll(0, _this2.messages.scrollHeight);\n      });\n      this.socketIO.on('banned', function (data) {\n        window.location.replace(window.location.href);\n      });\n    }\n    /**\r\n     * ================================\r\n     *  Emit Messages througth socket\r\n     * ================================\r\n     */\n\n  }, {\n    key: \"emitMessage\",\n    value: function emitMessage() {\n      /* Emit the message */\n      var url = new URLSearchParams(window.location.search);\n      var adminID = url.get('adminID');\n\n      if (this.inputChat.value != '') {\n        this.socketIO.emit('Chat Message', {\n          text: this.inputChat.value,\n          adminID: adminID\n        });\n        /* Reset the content */\n\n        this.inputChat.value = \"\";\n      }\n    }\n  }]);\n\n  return OnlineChat;\n}();\n\n\n\n//# sourceURL=webpack:///./server/client/js/classes/OnlineChat.js?");

/***/ }),

/***/ "./server/client/js/classes/State.js":
/*!*******************************************!*\
  !*** ./server/client/js/classes/State.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n *  ===========================\r\n *     MANAGE GAME STATE\r\n *  ===========================\r\n */\nvar State = /*#__PURE__*/function () {\n  function State(callback) {\n    _classCallCheck(this, State);\n\n    /* Delay behind server time */\n    this.RENDER_DELAY = 60;\n    /* buffer to push new packet states */\n\n    this.buffer = [];\n    /* game starting point in time */\n\n    this.gameStart = 0;\n    /* First server time stamp */\n\n    this.firstServerTimestamp = 0;\n    /* Testing callback */\n\n    this.callback = callback;\n  }\n  /**\r\n   *  ===================================\r\n   *      PUSH A NEW SERVER STATE\r\n   *  ===================================\r\n   */\n\n\n  _createClass(State, [{\n    key: \"processGameUpdate\",\n    value: function processGameUpdate(update) {\n      if (!this.firstServerTimestamp) {\n        this.firstServerTimestamp = update.serverTime;\n        this.gameStart = Date.now();\n      }\n\n      this.buffer.push(update); // Keep only one game update before the current server time\n\n      var base = this.getBaseUpdate();\n\n      if (base > 0) {\n        this.buffer.splice(0, base);\n      }\n    }\n  }, {\n    key: \"getBaseUpdate\",\n    value: function getBaseUpdate() {\n      var serverTime = this.currentServerTime();\n      this.callback(Date.now() - serverTime);\n\n      for (var i = this.buffer.length - 1; i >= 0; i--) {\n        if (this.buffer[i].serverTime <= serverTime) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n    /* get current time of the state in the server */\n\n  }, {\n    key: \"currentServerTime\",\n    value: function currentServerTime() {\n      return this.firstServerTimestamp + (Date.now() - this.gameStart) - this.RENDER_DELAY;\n    }\n  }, {\n    key: \"getCurrentState\",\n    value: function getCurrentState() {\n      if (!this.firstServerTimestamp) {\n        return {};\n      }\n\n      var base = this.getBaseUpdate();\n      var serverTime = this.currentServerTime(); // If base is the most recent update we have, use its state.\n      // Otherwise, interpolate between its state and the state of (base + 1).\n\n      if (base < 0 || base === this.buffer.length - 1) {\n        return this.buffer[this.buffer.length - 1];\n      } else {\n        var baseUpdate = this.buffer[base];\n        var next = this.buffer[base + 1];\n        var ratio = (serverTime - baseUpdate.serverTime) / (next.serverTime - baseUpdate.serverTime);\n        /* If a team lobby then interpolate each team individually */\n\n        if (Array.isArray(baseUpdate.players)) {\n          console.log(this.interpolateBullets(baseUpdate.bullets, next.bullets, ratio));\n          var interpolatedState = {\n            players: [this.interpolatePlayers(baseUpdate.players[0], next.players[0], ratio), this.interpolatePlayers(baseUpdate.players[1], next.players[1], ratio)],\n            bullets: this.interpolateBullets(baseUpdate.bullets, next.bullets, ratio),\n            bonusKits: baseUpdate.bonusKits\n          };\n          if (baseUpdate.flags) interpolatedState.flags = baseUpdate.flags;\n          return interpolatedState;\n        } else {\n          return {\n            players: this.interpolatePlayers(baseUpdate.players, next.players, ratio),\n            bullets: this.interpolateBullets(baseUpdate.bullets, next.bullets, ratio),\n            bonusKits: baseUpdate.bonusKits\n          };\n        }\n      }\n    }\n    /**\r\n     *    ========================\r\n     *         INTERPOLATION\r\n     *    ========================\r\n     */\n\n    /* Interpolate position between packets */\n\n  }, {\n    key: \"interpolatePlayers\",\n    value: function interpolatePlayers(base, next, ratio) {\n      var _this = this;\n\n      /* Interpolated state */\n      var interpolated = {};\n      Object.entries(base).map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            id = _ref2[0],\n            player = _ref2[1];\n\n        /* In order to interpolate the next packet from server must've been received*/\n        if (next[id]) {\n          /* Position calculated between packets */\n          var interpolatedPosition = _this.interpolatePosition(base[id], next[id], ratio);\n\n          player.posX = interpolatedPosition.x;\n          player.posY = interpolatedPosition.y;\n          interpolated[id] = player;\n        }\n      });\n      return interpolated;\n    }\n    /* Interpolate bullets */\n\n  }, {\n    key: \"interpolateBullets\",\n    value: function interpolateBullets(base, next, ratio) {\n      var _this2 = this;\n\n      /* Loop through the bullet's array and inteprolate each entry's position */\n      return base.map(function (bullet) {\n        var futureBullet = next.find(function (nextBullet) {\n          return nextBullet.timeStamp === bullet.timeStamp && nextBullet.ownerID === bullet.ownerID;\n        });\n\n        if (futureBullet) {\n          var interpolatedPosition = _this2.interpolatePosition(bullet, futureBullet, ratio);\n\n          bullet.posX = interpolatedPosition.x;\n          bullet.posY = interpolatedPosition.y;\n        }\n\n        return bullet;\n      });\n    }\n    /* Interpolate single values */\n\n  }, {\n    key: \"interpolatePosition\",\n    value: function interpolatePosition(current, next, ratio) {\n      return {\n        x: current.posX + (next.posX - current.posX) * ratio,\n        y: current.posY + (next.posY - current.posY) * ratio\n      };\n    }\n  }]);\n\n  return State;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (State);\n\n//# sourceURL=webpack:///./server/client/js/classes/State.js?");

/***/ }),

/***/ "./server/client/js/teams.js":
/*!***********************************!*\
  !*** ./server/client/js/teams.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_classes_Online_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../js/classes/Online.js */ \"./server/client/js/classes/Online.js\");\n\n/**\r\n * ==================================\r\n *          Team Deathmatch\r\n * ==================================\r\n */\n\n/* Creating the Glide object to show the available skins */\n\nvar play = document.getElementById('play');\n/* HTML body */\n\nvar body = document.getElementsByTagName('body')[0];\n/* select team screen */\n\nvar selectTeam = document.getElementById('select-teams');\n/* Start server */\n\nvar socket = io();\nvar game;\n/* Player name */\n\nvar name;\n/* Has the user pressed the play button? */\n\nvar pressedPlay = false;\n/* Team members of each team */\n\nvar teammembersBlue = document.getElementById('blue-team-players');\nvar teammembersRed = document.getElementById('red-team-players');\n/* Players in the lobby */\n\nvar players;\n\nvar createEngine = function createEngine(team) {\n  /* show background when a team has been selected */\n  document.getElementById('background-frame').style.display = 'block';\n  document.getElementById('site-ajax-loader').style.display = 'block';\n  body.removeChild(selectTeam);\n  var mode;\n  if (location.pathname === '/teams') mode = 1;else if (location.pathname === '/ctf') mode = 2;\n  var engine = new _js_classes_Online_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](game.lobby.map, game.lobby.collisionMatrix, game.lobby.shadowMap, game.lobby.tileSet, document.getElementById('game'), socket, game.playerID, game.lobby.server, characterSkins[glide.index], name, {\n    mode: mode,\n    team: team\n  });\n};\n/**\r\n *  =================================\r\n *      ADD SELECT TEAMS LISTENERS\r\n *  =================================\r\n */\n\n\nvar selectRedTeam = document.getElementById('site-red-team');\nvar selectBlueTeam = document.getElementById('site-blue-team');\n/* Enter red team */\n\nselectRedTeam.onclick = function (e) {\n  createEngine(1);\n};\n/* Enter blue team */\n\n\nselectBlueTeam.onclick = function (e) {\n  createEngine(0);\n};\n/**\r\n *  =======================================\r\n *      PLAYER HAS SELECTED A CHARACTER\r\n *  =======================================\r\n */\n\n\nplay.onclick = function () {\n  pressedPlay = true;\n  name = document.getElementById('playerName').value || 'unnamed';\n  /* remove select characters frame */\n\n  body.removeChild(document.getElementById('login-frame'));\n  /* show select teams screen */\n\n  selectTeam.style.display = 'block';\n  /* hide background until a team's been selected */\n\n  document.getElementById('background-frame').style.display = 'none';\n  /* Show current players in lobby */\n\n  displayPlayers(players.blues, teammembersBlue);\n  displayPlayers(players.reds, teammembersRed);\n};\n\nsocket.on('loadMap', function (data) {\n  game = data;\n});\nsocket.on('load team members', function (data) {\n  players = data;\n  /* If we've already clicked play and are at the selecte team screen refresh team-members */\n\n  if (pressedPlay && document.getElementById('select-teams')) {\n    /* Clear team members */\n    teammembersBlue.innerHTML = \"\";\n    teammembersRed.innerHTML = \"\";\n    /* Refresh members of each team */\n\n    displayPlayers(players.blues, teammembersBlue);\n    displayPlayers(players.reds, teammembersRed);\n  }\n});\n/* Display players on the lobby */\n\nfunction displayPlayers(players, div) {\n  players.map(function (player) {\n    /* External player's div */\n    var divPlayer = document.createElement('div');\n    divPlayer.className = \"lobby-player\";\n    /* Playername */\n\n    var playerName = document.createElement('p');\n    playerName.innerHTML = player.name;\n    divPlayer.append(images.find(function (image) {\n      return image.src.includes(player.skin);\n    }).cloneNode());\n    divPlayer.append(playerName);\n    div.append(divPlayer);\n  });\n}\n\n//# sourceURL=webpack:///./server/client/js/teams.js?");

/***/ })

/******/ });