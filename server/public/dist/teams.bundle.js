/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./server/client/js/teams.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./server/client/js/character.js":
/*!***************************************!*\
  !*** ./server/client/js/character.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* \r\n    ========================\r\n        Character Object\r\n    ========================\r\n*/\nvar character = {\n  deathCharacter: false,\n\n  /* Sprites */\n  currentSprite: {\n    x: 0,\n    y: 5,\n    flip: 1\n  },\n  spriteSheet: {\n    img: null,\n    width: 64,\n    height: 64\n  },\n\n  /* Animations */\n  animationSpeed: 250,\n  moveInterval: undefined,\n\n  /* Matrix position */\n  posY: null,\n  posX: null,\n\n  /* Load the sprites for the given character */\n  load: function load(name, callback) {\n    var _this = this;\n\n    /* Load sprite for character */\n    var sprite = new Image();\n\n    sprite.onload = function () {\n      _this.spriteSheet.img = sprite;\n      callback();\n    };\n\n    sprite.src = \"../assets/characters/\".concat(name);\n  },\n\n  /* Change the image when moving forward */\n  onMovingForward: function onMovingForward() {\n    this.currentSprite.y = 2;\n    this.createInterval();\n  },\n  onMovingBackwards: function onMovingBackwards() {\n    this.currentSprite.y = 0;\n    this.createInterval();\n  },\n  onMovingLeft: function onMovingLeft() {\n    this.currentSprite.y = 1;\n    this.currentSprite.flip = -1;\n    this.createInterval();\n  },\n  onMovingRight: function onMovingRight() {\n    this.currentSprite.y = 1;\n    this.currentSprite.flip = 1;\n    this.createInterval();\n  },\n  onMovingForwardLeft: function onMovingForwardLeft() {\n    this.currentSprite.y = 3;\n    this.currentSprite.flip = -1;\n    this.createInterval();\n  },\n  onMovingForwardRight: function onMovingForwardRight() {\n    this.currentSprite.y = 3;\n    this.currentSprite.flip = 1;\n    this.createInterval();\n  },\n  onMovingBackwardsRight: function onMovingBackwardsRight() {\n    this.currentSprite.y = 4;\n    this.currentSprite.flip = 1;\n    this.createInterval();\n  },\n  onMovingBackwardsLeft: function onMovingBackwardsLeft() {\n    this.currentSprite.y = 4;\n    this.currentSprite.flip = -1;\n    this.createInterval();\n  },\n  createInterval: function createInterval() {\n    var _this2 = this;\n\n    this.currentSprite.x = 0;\n    this.moveInterval = setInterval(function () {\n      _this2.currentSprite.x++;\n      if (_this2.currentSprite.x > 3) _this2.currentSprite.x = 0;\n    }, this.animationSpeed);\n  },\n\n  /* Delete  */\n  onMovingStop: function onMovingStop() {\n    clearInterval(this.moveInterval);\n    this.currentSprite.x = 0;\n    this.currentSprite.y = 5;\n    this.moveInterval = null;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (character);\n\n//# sourceURL=webpack:///./server/client/js/character.js?");

/***/ }),

/***/ "./server/client/js/classes/Engine.js":
/*!********************************************!*\
  !*** ./server/client/js/classes/Engine.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Engine; });\n/* harmony import */ var _character_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../character.js */ \"./server/client/js/character.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n/**\r\n * ============================\r\n *         ENGINE CLASS\r\n * ============================\r\n */\n\nvar Engine = /*#__PURE__*/function () {\n  function Engine(map, collisionMatrix, shadowMatrix, tileset, canvas, skin) {\n    var _this = this;\n\n    _classCallCheck(this, Engine);\n\n    this.resizeCanvas = function () {\n      //let self = engine\n      var tempWidth = _this.tileMap.width,\n          tempHeight = _this.tileMap.height;\n      /* Dimension of the general canvas */\n\n      _this.canvas.width = window.innerWidth;\n      /* Tile width and height responsive */\n\n      _this.tile.width = _this.canvas.width / _this.screenTiles.x;\n      _this.tile.height = _this.canvas.width * _this.frameRatio / _this.screenTiles.y;\n      /* Dimensions of the tile map */\n\n      _this.tileMap.width = _this.tileMap.tiles[0].length * _this.tile.width;\n      _this.tileMap.height = _this.tileMap.tiles.length * _this.tile.height;\n      _this.canvas.height = _this.canvas.width * _this.frameRatio < window.innerHeight ? _this.canvas.width * _this.frameRatio : window.innerHeight;\n      /* Start points responsive -> rule of 3*/\n\n      _this.tileMap.startX = _this.tileMap.startX * _this.tileMap.width / tempWidth;\n      _this.tileMap.startY = _this.tileMap.startY * _this.tileMap.height / tempHeight;\n      /* Camera smoothness ratio */\n\n      _this.cameraSmoothness.limitX = _this.canvas.width * .045;\n      _this.cameraSmoothness.limitY = _this.canvas.height * .045;\n      /* Bullet's size */\n\n      _this.bulletSprite.width = _this.canvas.width * .02;\n      _this.bulletSprite.height = _this.canvas.width * .02;\n      /* Set player's position */\n\n      _this.playerRelativePosition = _this.getPlayerRelativePosition();\n    };\n\n    this.triggerShooting = function (dir, spriteY) {\n      // Testing variables for shooting\n      //console.log(`able to shoot: ${this.ableToShoot} ; controls shoot: ${this.controls.shoot} ; chat inactive: ${this.chat.active} ; ammo : ${this.currentAmmo} ; reloading: ${this.reloading}`)\n      if (_this.ableToShoot && _this.controls.shoot && !_this.chat.active && _this.currentAmmo && !_this.reloading) {\n        _this.ableToShoot = false;\n        setTimeout(function () {\n          _this.ableToShoot = true;\n        }, _this.shootingDelay);\n        /* Fire animation */\n\n        setTimeout(function () {\n          _this.emitBullet(dir, spriteY);\n        }, 70);\n      }\n    };\n\n    /* General variables */\n    this.canvas = canvas;\n    this.context = this.canvas.getContext(\"2d\");\n    /* List with single tiles -> no-repeated img -> Use to load only one image for each value */\n\n    this.tileList = [];\n    /* Array that stores -> id = in the map matrix AND img = Image object */\n\n    this.tileImages = [];\n    this.localGame = null;\n    this.skin = skin;\n    /* Total amount of ammo for the character selected */\n\n    this.playerAmmunition = null;\n    this.currentAmmo = null;\n    this.reloading = false;\n    this.shootingDelay = null;\n    this.ableToShoot = true;\n    /* Html <p> that shows the amount of bullets in the charger */\n\n    this.bulletsHTMLElement = document.getElementById('charger');\n    this.character = _character_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    /* Tile properties */\n\n    this.tile = {\n      width: null,\n      height: null\n    };\n    /*  TileMap Object -> properties and tiles  */\n\n    this.tileMap = {\n      tileSet: tileset,\n      tiles: map,\n      startX: 200,\n      startY: 200,\n      width: 1280,\n      height: 720\n    };\n    /* Tiles per screen */\n\n    this.screenTiles = {\n      x: 16,\n      y: 9\n    };\n    this.frameDefaultDimensions = {\n      width: 1280,\n      height: 720\n    };\n    /* Player stats */\n\n    this.playerStats = null;\n    /* Calculate the average ratio of the screen */\n\n    this.frameRatio = this.frameDefaultDimensions.height / this.frameDefaultDimensions.width;\n    this.offSet = {\n      x: null,\n      y: null,\n      xLimit: null,\n      yLimit: null\n    };\n    /* Relative position of player */\n\n    this.playerRelativePosition = null;\n    /* FPS Counter */\n\n    this.lastFrameTime = 0;\n    this.FPS = 0;\n    /* Static Animation */\n\n    this.staticAnimation = {\n      interval: null,\n      x: 0\n    };\n    /* Collisionable */\n\n    this.collisionMatrix = collisionMatrix;\n    /* Shadow matrix */\n\n    this.shadowMatrix = shadowMatrix;\n    this.shooting = false;\n    /* Animation? */\n\n    this.animatedSprites = false;\n    /* Camera smoothness */\n\n    this.cartesianValueOfMovement = {\n      x: 0,\n      y: 0\n    };\n    this.cameraSmoothness = {\n      velX: .5,\n      velY: 2,\n      friction: .98,\n      offsetX: 0,\n      offsetY: 0\n    };\n    /* Bullets Image */\n\n    this.bulletSprite = {\n      width: null,\n      height: null,\n      img: null\n    };\n    /* Get the timings of the animation 0-4 */\n\n    this.animationTiming = 1;\n    /**\r\n     *  =========================\r\n     *          COLORS\r\n     *  =========================\r\n     */\n\n    this.colors = {\n      enemy: '#eb3d11',\n      self: ' #00b7ff',\n      ally: '#00ff00'\n    };\n    window.addEventListener('resize', this.resizeCanvas);\n    this.resizeCanvas();\n    this.load();\n  }\n  /* \r\n      =================\r\n          LOAD TILES\r\n      =================\r\n  */\n\n\n  _createClass(Engine, [{\n    key: \"load\",\n    value: function load() {\n      var _this2 = this;\n\n      console.log(this.tileList);\n      console.log(this.tileImages);\n      console.log(this.tileMap.tiles);\n      console.log(this.collisionMatrix);\n      console.log(this.shadowMatrix);\n\n      var pushImg = function pushImg(val) {\n        if (Array.isArray(val)) {\n          val.forEach(function (value) {\n            return pushImg(value);\n          });\n          _this2.animatedSprites = true;\n        } else {\n          if (val !== 0 && _this2.tileList.indexOf(val) < 0) _this2.tileList.push(val);\n        }\n      };\n      /* Retrieve single tile values */\n\n\n      for (var i = 0; i < this.tileMap.tiles.length; i++) {\n        for (var j = 0; j < this.tileMap.tiles[0].length; j++) {\n          pushImg(this.tileMap.tiles[i][j]);\n          pushImg(this.collisionMatrix[i][j]);\n          pushImg(this.shadowMatrix);\n        }\n      }\n\n      var loadedImages = 0; // Check if all images have been loaded\n\n      for (var _i = 0; _i < this.tileList.length; _i++) {\n        var tileImage = new Image();\n\n        tileImage.onload = function () {\n          if (++loadedImages >= _this2.tileList.length) {\n            _this2.bulletSprite.img = new Image();\n\n            _this2.bulletSprite.img.onload = function () {\n              _this2.loadCharacter();\n            };\n\n            _this2.bulletSprite.img.src = '../assets/resources/bullets.png';\n          }\n        };\n\n        tileImage.src = \"../assets/tiles/\".concat(this.tileMap.tileSet, \"/tile_00\").concat(this.tileList[_i] < 10 ? '0' + this.tileList[_i] : this.tileList[_i], \".png\");\n        this.tileImages.push({\n          id: this.tileList[_i],\n          img: tileImage\n        });\n      }\n    }\n  }, {\n    key: \"loadCharacter\",\n    value: function loadCharacter() {\n      var _this3 = this;\n\n      this.character.load(\"\".concat(this.skin, \".png\"), function () {\n        if (_this3.animatedSprites) _this3.setAnimationTiming();\n\n        _this3.closeLoadingScreen();\n\n        requestAnimationFrame(_this3.render);\n      });\n    }\n    /* Shut loading screen once every element's been downloaded */\n\n  }, {\n    key: \"closeLoadingScreen\",\n    value: function closeLoadingScreen() {\n      /* Show game */\n      var body = document.getElementsByTagName('body')[0];\n      body.classList.remove('background-connect-frame');\n      document.getElementById('site-ajax-loader').style.display = 'none';\n      document.getElementById('site-game').style.display = 'block';\n      document.getElementById('background-frame').style.display = 'none';\n    }\n    /* Auto resize the canvas when the screen is resized */\n\n  }, {\n    key: \"calculateOffset\",\n\n    /**\r\n     * =================================\r\n     *  GENERAL FUNCTIONS FOR RENDERING\r\n     * =================================\r\n     */\n\n    /* Calculate which tiles are to be drawn within the screen */\n    value: function calculateOffset() {\n      this.offSet.x = this.tileMap.startX < 0 ? Math.floor(-this.tileMap.startX / this.tile.width) : 0;\n      this.offSet.y = this.tileMap.startY < 0 ? Math.floor(-this.tileMap.startY / this.tile.height) : 0;\n      var offsetX = this.screenTiles.x + Math.floor(-this.tileMap.startX / this.tile.width) + 1;\n      var offsetY = this.screenTiles.y + Math.floor(-this.tileMap.startY / this.tile.height) + 1;\n      this.offSet.xLimit = offsetX > this.tileMap.tiles[0].length ? this.tileMap.tiles[0].length : offsetX;\n      this.offSet.yLimit = offsetY > this.tileMap.tiles.length ? this.tileMap.tiles.length : offsetY;\n    }\n    /* Draw Map function */\n\n  }, {\n    key: \"drawMap\",\n    value: function drawMap() {\n      for (var i = this.offSet.y; i < this.offSet.yLimit; i++) {\n        for (var j = this.offSet.x; j < this.offSet.xLimit; j++) {\n          this.drawTile(j, i, this.tileMap.tiles);\n        }\n      }\n    }\n  }, {\n    key: \"drawShadows\",\n    value: function drawShadows() {\n      for (var i = this.offSet.y; i < this.offSet.yLimit; i++) {\n        for (var j = this.offSet.x; j < this.offSet.xLimit; j++) {\n          if (this.shadowMatrix[i][j]) this.drawTile(j, i, this.shadowMatrix);\n        }\n      }\n    }\n    /* Draw objects from collision matrix */\n\n  }, {\n    key: \"drawObjects\",\n    value: function drawObjects() {\n      for (var i = this.offSet.y; i < this.offSet.yLimit; i++) {\n        for (var j = this.offSet.x; j < this.offSet.xLimit; j++) {\n          if (this.collisionMatrix[i][j]) this.drawTile(j, i, this.collisionMatrix);\n        }\n      }\n    }\n    /* Draw single tile on canvas */\n\n  }, {\n    key: \"drawTile\",\n    value: function drawTile(xi, yi, matrix) {\n      var _this4 = this;\n\n      var indexImage = Array.isArray(matrix[yi][xi]) ? this.tileImages.findIndex(function (elem) {\n        return elem.id === matrix[yi][xi][_this4.animationTiming];\n      }) : this.tileImages.findIndex(function (elem) {\n        return elem.id === matrix[yi][xi];\n      });\n      if (matrix[yi][xi] !== 0) this.context.drawImage(this.tileImages[indexImage].img, xi * this.tile.width + this.tileMap.startX, yi * this.tile.height + this.tileMap.startY, this.tile.width, this.tile.height);\n    }\n  }, {\n    key: \"drawCharacter\",\n    value: function drawCharacter() {\n      var spriteSheetPos = this.playerStats.life === 0 ? {\n        x: 1,\n        y: 8\n      } : this.character.currentSprite;\n      this.context.drawImage(this.character.spriteSheet.img, spriteSheetPos.x * this.character.spriteSheet.width, spriteSheetPos.y * this.character.spriteSheet.height, this.character.spriteSheet.width, this.character.spriteSheet.height, this.playerRelativePosition.posX, this.playerRelativePosition.posY, this.tile.width, this.tile.height);\n    }\n    /* In case of animated tile -> set the timing for every tile */\n\n  }, {\n    key: \"setAnimationTiming\",\n    value: function setAnimationTiming() {\n      var _this5 = this;\n\n      setInterval(function () {\n        if (_this5.animationTiming === 4) _this5.animationTiming = 0;else _this5.animationTiming++;\n      }, 350);\n    }\n    /**\r\n     *  =======================================\r\n     *    FUNCTIONS TO CALCULATE POSITIONS\r\n     *  =======================================\r\n     */\n\n  }, {\n    key: \"getPlayerPosition\",\n    value: function getPlayerPosition() {\n      var posX = Math.floor((this.tileMap.width / 2 - this.tileMap.startX) / this.tile.width);\n      var posY = Math.floor((this.tileMap.height / 2 - this.tileMap.startY) / this.tile.height); //console.log(`${posX}, ${posY}`)\n\n      return {\n        posX: posX,\n        posY: posY\n      };\n    }\n    /* Get player realtive position to the screen size */\n\n  }, {\n    key: \"getPlayerRelativePosition\",\n    value: function getPlayerRelativePosition() {\n      var posX = this.screenTiles.x * this.tile.width / 2 - this.tile.width / 2;\n      var posY = this.screenTiles.y * this.tile.height / 2 - this.tile.height / 2;\n      return {\n        posX: posX,\n        posY: posY\n      };\n    }\n    /* returns position of a given position in the matrix relative to the screen */\n\n  }, {\n    key: \"getTilesRelativePosition\",\n    value: function getTilesRelativePosition(x, y) {\n      var posX = x * this.tile.width + this.tileMap.startX;\n      var posY = y * this.tile.height + this.tileMap.startY;\n      return {\n        posX: posX,\n        posY: posY\n      };\n    }\n    /* Draw life of an entity */\n\n  }, {\n    key: \"drawLife\",\n    value: function drawLife(posX, posY, life, color) {\n      this.context.beginPath();\n      this.context.rect(posX, posY, this.tile.width, this.tile.height / 10);\n      this.context.stroke();\n      this.context.beginPath();\n      this.context.rect(posX, posY, this.tile.width * life / 100, this.tile.height / 10);\n      this.context.fillStyle = color;\n      this.context.fill();\n      this.context.closePath();\n      this.context.restore();\n    }\n    /** \r\n     *  =========================\r\n     *      SHOOTING MECHANICS\r\n     *  =========================\r\n    */\n\n    /* Shooting timing */\n\n  }]);\n\n  return Engine;\n}();\n\n\n\n//# sourceURL=webpack:///./server/client/js/classes/Engine.js?");

/***/ }),

/***/ "./server/client/js/classes/Joystick.js":
/*!**********************************************!*\
  !*** ./server/client/js/classes/Joystick.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Joystick; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * ===============================\r\n *        Joystick Class\r\n * ===============================\r\n * \r\n * @constructor\r\n * \r\n * @param canvas {Object} - HTML canvas element where the joystick will be drawn\r\n * @param position {Object} - X and Y positions to draw the joystick\r\n * @param radius {Integer} - Radius of the outter circle -> inner will be drawn based on this value (60% of outter)\r\n * @param internalFillColor {String} (optional) - Internal color of inner circle\r\n * @param internalStrokeColor {String} (optional) - Border color of inner circle\r\n * \r\n */\nvar Joystick = /*#__PURE__*/function () {\n  function Joystick(canvas, character, emitPosition, emitBullet, internalFillColor, internalStrokeColor) {\n    var _this = this;\n\n    _classCallCheck(this, Joystick);\n\n    this.resize = function () {\n      /* radius of outter circle */\n      _this.radius = _this.canvas.width * .07;\n      /* Stablishing dimensions */\n\n      _this.position = {\n        x: _this.radius + _this.canvas.width * .07,\n        y: _this.canvas.height - (_this.radius + _this.canvas.height * 0.1)\n      };\n      /* Outer circle */\n\n      _this.outterCircle = {\n        x: _this.position.x,\n        y: _this.position.y,\n        radius: _this.radius\n      };\n      /* Inner circle */\n\n      _this.innerCircle = {\n        x: _this.position.x,\n        y: _this.position.y,\n        radius: _this.radius * .60\n      };\n      /* Shoot button */\n\n      _this.shootButton = {\n        x: _this.canvas.width - _this.radius - _this.canvas.width * .07,\n        y: _this.position.y,\n        radius: _this.radius * .6\n      };\n\n      _this.drawJoystick();\n    };\n\n    this.handleStart = function (e) {\n      /* Determine if user is clicking the inner circle -> implemented using pythagoras */\n      e.preventDefault();\n      /* Push the new finger onto the buffer */\n\n      _this.touchingFingers.push(e.changedTouches[0].identifier);\n\n      var posJoystick = _this.touchingFingers[_this.indexJoystick];\n      /* If touching the joystick */\n\n      if (!isNaN(posJoystick) && Math.pow(e.changedTouches[0].pageX - _this.innerCircle.x, 2) + Math.pow(e.changedTouches[0].pageY - _this.innerCircle.y, 2) <= Math.pow(_this.innerCircle.radius, 2)) {\n        _this.dragging = true;\n        /* Set index on touch event's array */\n\n        if (!_this.shoot) {\n          _this.indexJoystick = 0;\n          _this.indexShootButton = 1;\n        }\n      }\n\n      var posShootButton = _this.touchingFingers[_this.indexShootButton];\n      /* If touching the shoot button */\n\n      if (!isNaN(posShootButton) && Math.pow(e.changedTouches[0].pageX - _this.shootButton.x, 2) + Math.pow(e.changedTouches[0].pageY - _this.shootButton.y, 2) <= Math.pow(_this.shootButton.radius, 2)) {\n        _this.shoot = true;\n        /* Set index on touch event's array */\n\n        if (!_this.dragging) {\n          _this.indexShootButton = 0;\n          _this.indexJoystick = 1;\n        }\n      }\n    };\n\n    this.handleMovement = function (e) {\n      e.preventDefault();\n      /* if clicked */\n\n      if (_this.dragging) {\n        var source = window.mobileCheck() ? e.touches[_this.indexJoystick] : e;\n        var mx = source.pageX;\n        var my = source.pageY;\n        var angle = Math.atan((my - _this.outterCircle.y) / (mx - _this.outterCircle.x));\n        /* Move freely while in the outer circle */\n\n        if (Math.pow(mx - _this.outterCircle.x, 2) + Math.pow(my - _this.outterCircle.y, 2) <= Math.pow(_this.outterCircle.radius, 2)) {\n          _this.innerCircle.x = mx;\n          _this.innerCircle.y = my;\n        } else {\n          /* When the cursor is outside outer function then predict the position of inner circle\r\n              using sin and cos */\n          var offsetX;\n          var offsetY;\n\n          if (mx < _this.outterCircle.x) {\n            offsetX = _this.outterCircle.x - _this.radius * Math.cos(angle) - mx;\n            _this.innerCircle.x = mx + offsetX;\n          } else {\n            offsetX = mx - (_this.outterCircle.x + _this.radius * Math.cos(angle));\n            _this.innerCircle.x = mx - offsetX;\n          }\n\n          if (my < _this.outterCircle.y) {\n            offsetY = _this.outterCircle.y - _this.radius * Math.sign(angle) * Math.sin(angle) - my;\n            _this.innerCircle.y = my + offsetY;\n          } else {\n            offsetY = my - (_this.outterCircle.y + _this.radius * Math.sign(angle) * Math.sin(angle));\n            _this.innerCircle.y = my - offsetY;\n          }\n        }\n        /* Compute the values of movement for characters */\n\n\n        _this.computeAngles(mx - _this.outterCircle.x, _this.outterCircle.y - my, angle);\n      }\n    };\n\n    this.handleReleased = function (e) {\n      e.preventDefault(); //console.log(` Joystick: ${this.indexJoystick} AND shootButton: ${this.indexShootButton}`);\n\n      for (var i = 0; i < e.changedTouches.length; i++) {\n        if (_this.touchingFingers[_this.indexJoystick] === e.changedTouches[i].identifier) {\n          _this.dragging = false;\n\n          _this.touchingFingers.splice(_this.indexJoystick, 1);\n          /* When released click then return to original position */\n\n\n          _this.innerCircle.x = _this.position.x;\n          _this.innerCircle.y = _this.position.y;\n          _this.movement = {\n            x: 0,\n            y: 0\n          };\n          /* Stop animation */\n\n          if (_this.character.moveInterval) _this.character.onMovingStop();\n          /* Reset cartesian value */\n\n          _this.cartesianValueOfMovement = {\n            x: 0,\n            y: 0\n          };\n          /* Only swap indexes when the one released is smaller */\n\n          if (_this.indexJoystick < _this.indexShootButton) {\n            var temp = _this.indexJoystick;\n            _this.indexJoystick = _this.indexShootButton;\n            _this.indexShootButton = temp;\n          }\n        }\n\n        if (_this.touchingFingers[_this.indexShootButton] === e.changedTouches[i].identifier) {\n          _this.touchingFingers.splice(_this.indexShootButton, 1);\n\n          _this.shoot = false;\n          /* Only swap indexes when the one released is smaller */\n\n          if (_this.indexShootButton < _this.indexJoystick) {\n            var _temp = _this.indexJoystick;\n            _this.indexJoystick = _this.indexShootButton;\n            _this.indexShootButton = _temp;\n          }\n        } //console.log(`Shooting: ${this.shoot} , Dragging: ${this.dragging}`);\n\n        /* If no finger is touching the screen then both indexes are 0; both will be waiting in the first position */\n\n\n        if (_this.touchingFingers.length == 0) {\n          _this.indexJoystick = 0;\n          _this.indexShootButton = 0;\n        }\n\n        _this.emitPosition(_this.movement);\n      }\n    };\n\n    /* Drawing canvas */\n    this.canvas = canvas;\n    this.context = canvas.getContext(\"2d\");\n    /* Cos and sin */\n\n    this.movement = {\n      cos: 0,\n      sin: 0\n    };\n    this.angleInDegrees = 0;\n    /* Dragging */\n\n    this.dragging = false;\n    this.shoot = false;\n    /* Color and Design */\n\n    this.internalFillColor = internalFillColor || \"rgba(255,255,255,0.8)\";\n    /* Color when pressed */\n\n    this.internalPressedColor = \"rgba(255,255,255,0.4)\";\n    /* Character sprite */\n\n    this.character = character;\n    /* State of the movement */\n\n    this.movement = {\n      x: 0,\n      y: 0\n    };\n    /* Callbacks */\n\n    this.emitPosition = emitPosition;\n    this.emitBullet = emitBullet;\n    /* Cartesian Value of movement */\n\n    this.cartesianValueOfMovement = {\n      x: 0,\n      y: 0,\n      shoot: false\n    };\n    /* Bullet direction */\n\n    this.bulletDir = {\n      x: 0,\n      y: 0\n    };\n    /* Manage indexes of touch events */\n\n    this.indexJoystick = 0;\n    this.indexShootButton = 0;\n    /* Keep track of fingers touching the screen */\n\n    this.touchingFingers = [];\n    this.addListeners();\n  }\n\n  _createClass(Joystick, [{\n    key: \"drawJoystick\",\n    value: function drawJoystick() {\n      this.context.lineWidth = 2;\n      /* Filling style */\n\n      this.context.fillStyle = this.internalFillColor;\n      /* Draw outer circle */\n\n      this.context.beginPath();\n      this.context.arc(this.outterCircle.x, this.outterCircle.y, this.outterCircle.radius, 0, Math.PI * 2);\n      this.context.stroke();\n      /* Draw inner circle */\n\n      this.context.beginPath();\n      if (this.dragging) this.context.fillStyle = this.internalPressedColor;\n      this.context.arc(this.innerCircle.x, this.innerCircle.y, this.innerCircle.radius, 0, Math.PI * 2);\n      this.context.fill();\n      this.context.stroke();\n      /* Reset Filling style */\n\n      this.context.fillStyle = this.internalFillColor;\n      /* Draw shooting circle */\n\n      this.context.beginPath();\n      if (this.shoot) this.context.fillStyle = this.internalPressedColor;\n      this.context.arc(this.shootButton.x, this.shootButton.y, this.shootButton.radius, 0, Math.PI * 2);\n      this.context.fill();\n      this.context.stroke();\n      /* Draw text under shoot circle */\n\n      this.context.textAlign = 'center';\n      this.context.strokeText('Shoot', this.shootButton.x, this.shootButton.y + 3);\n    }\n    /* Event listener to detect if the user is dragging */\n\n  }, {\n    key: \"addListeners\",\n    value: function addListeners() {\n      window.addEventListener('resize', this.resize);\n      this.resize();\n\n      if (window.mobileCheck()) {\n        this.canvas.addEventListener('touchstart', this.handleStart);\n        this.canvas.addEventListener('touchmove', this.handleMovement);\n        this.canvas.addEventListener('touchend', this.handleReleased);\n      } else {\n        this.canvas.addEventListener('mousedown', this.handleStart);\n        this.canvas.addEventListener('mouseup', this.handleReleased);\n        this.canvas.addEventListener('mousemove', this.handleMovement);\n      }\n    }\n    /* Resize joystick -> Responsive */\n\n  }, {\n    key: \"computeAngles\",\n\n    /**\r\n     *  @desc Compute value of character movement based on position of inner circle\r\n     * \r\n     *  @param x - inner circle's X position with regards to outter circle => innerCircleX - outterCircleX\r\n     *  @param y - inner circle's Y position with regards to outter circle => OutterCircleY - innerCircleY\r\n     * \r\n     *  Note: As Y axis is inverted on a canvas, then we must substract from outterCircle\r\n     * \r\n     *  @returns - Object with the value of movement on X and Y\r\n     * */\n    value: function computeAngles(x, y, angle) {\n      var movement = {\n        x: 0,\n        y: 0\n      };\n      /* Calculate the proportion of the distance to be moved */\n\n      var hypotenuse = Math.sqrt(Math.pow(this.outterCircle.x - this.innerCircle.x, 2) + Math.pow(this.innerCircle.y - this.outterCircle.y, 2));\n      /* Get porcentage of movement regards to inner circle's radius */\n\n      var proportionOfMovement = hypotenuse * 100 / this.outterCircle.radius;\n      var degreeAngle = angle * 180 / Math.PI;\n\n      if (x >= 0) {\n        if (y >= 0) {\n          movement = {\n            x: Math.cos(angle),\n            y: Math.sin(angle)\n          };\n          degreeAngle = -degreeAngle;\n        } else {\n          movement = {\n            x: Math.cos(angle),\n            y: Math.sin(angle)\n          };\n          degreeAngle = 360 - degreeAngle;\n        }\n      } else {\n        if (y >= 0) {\n          movement = {\n            x: -Math.cos(angle),\n            y: -Math.sin(angle)\n          };\n          degreeAngle = 180 - degreeAngle;\n        } else {\n          movement = {\n            x: -Math.cos(angle),\n            y: -Math.sin(angle)\n          };\n          degreeAngle -= 180;\n          degreeAngle = -degreeAngle;\n        }\n      }\n      /* Set bullet direction for future shooting */\n\n\n      this.bulletDir = {\n        x: movement.x,\n        y: movement.y\n      };\n      /* apply proportion of movement */\n\n      movement.x *= proportionOfMovement / 100;\n      movement.y *= proportionOfMovement / 100;\n      /* TESTING */\n      //console.log(`${movement.x}, ${movement.y}`);\n\n      this.movement.x = movement.x;\n      this.movement.y = movement.y;\n      this.cartesianValueOfMovement.x = this.movement.x;\n      this.cartesianValueOfMovement.y = -this.movement.y;\n      this.angleInDegrees = degreeAngle;\n    }\n    /* Animate -> emitPosition */\n\n  }, {\n    key: \"animate\",\n    value: function animate() {\n      if (this.movement.x || this.movement.y) {\n        //Calculate character animation\n        var angle = 22.5;\n\n        if ((this.angleInDegrees <= angle || this.angleInDegrees > 337.5) && this.character.currentSprite.y != 1) {\n          this.character.onMovingStop();\n          this.character.onMovingRight();\n        }\n\n        if (this.angleInDegrees > angle && this.angleInDegrees <= angle + 45 && this.character.currentSprite.y != 3) {\n          this.character.onMovingStop();\n          this.character.onMovingForwardRight();\n        } //Next animation if doesn't match\n\n\n        angle += 45;\n\n        if (this.angleInDegrees > angle && this.angleInDegrees <= angle + 45 && this.character.currentSprite.y != 2) {\n          this.character.onMovingStop();\n          this.character.onMovingForward();\n        } //Next animation if doesn't match\n\n\n        angle += 45;\n\n        if (this.angleInDegrees > angle && this.angleInDegrees <= angle + 45 && this.character.currentSprite.y != 3) {\n          this.character.onMovingStop();\n          this.character.onMovingForwardLeft();\n        } //Next animation if doesn't match\n\n\n        angle += 45;\n\n        if (this.angleInDegrees > angle && this.angleInDegrees <= angle + 45 && this.character.currentSprite.y != 1) {\n          this.character.onMovingStop();\n          this.character.onMovingLeft();\n        } //Next animation if doesn't match\n\n\n        angle += 45;\n\n        if (this.angleInDegrees > angle && this.angleInDegrees <= angle + 45 && this.character.currentSprite.y != 4) {\n          this.character.onMovingStop();\n          this.character.onMovingBackwardsLeft();\n        } //Next animation if doesn't match\n\n\n        angle += 45;\n\n        if (this.angleInDegrees > angle && this.angleInDegrees <= angle + 45 && this.character.currentSprite.y != 0) {\n          this.character.onMovingStop();\n          this.character.onMovingBackwards();\n        } //Next animation if doesn't match\n\n\n        angle += 45;\n\n        if (this.angleInDegrees > angle && this.angleInDegrees <= angle + 45 && this.character.currentSprite.y != 4) {\n          this.character.onMovingStop();\n          this.character.onMovingBackwardsRight();\n        }\n\n        this.emitPosition(this.movement);\n      }\n\n      this.drawJoystick();\n      if (this.shoot) this.createBullet();\n    }\n    /* Create bullet trayectory and sprite of the animation */\n\n  }, {\n    key: \"createBullet\",\n    value: function createBullet() {\n      /* Direction of bullet's trayectory */\n      var dir = {\n        x: 0,\n        y: 0\n      };\n      var spriteY = 0;\n      /* Set trayectory */\n\n      if (this.character.currentSprite.y === 5) dir.x = 1 * this.character.currentSprite.flip;else dir = this.bulletDir;\n      /* Set bullet's sprite position in Y axis */\n\n      if (this.character.currentSprite.y === 1 || this.character.currentSprite.y === 5) spriteY = 2;\n      if (this.character.currentSprite.y === 3) spriteY = 1;\n      if (this.character.currentSprite.y === 4) spriteY = 3;\n      this.emitBullet(dir, spriteY);\n    }\n    /** \r\n     * ===============================\r\n     *      LISTENERS' CALLBACKS\r\n     * ===============================\r\n     * */\n\n  }]);\n\n  return Joystick;\n}();\n\n\n\n//# sourceURL=webpack:///./server/client/js/classes/Joystick.js?");

/***/ }),

/***/ "./server/client/js/classes/Keyboard.js":
/*!**********************************************!*\
  !*** ./server/client/js/classes/Keyboard.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Keyboard; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n *  ===============================\r\n *      Keyboard Controls Class\r\n *  ===============================\r\n */\nvar Keyboard = /*#__PURE__*/function () {\n  function Keyboard(character, emitPosition, emitBullet, emitReload) {\n    _classCallCheck(this, Keyboard);\n\n    /* Character -> in order to determine animations */\n    this.character = character;\n    /* Controls */\n\n    this.controls = {\n      goUp: false,\n      goDown: false,\n      goRight: false,\n      goLeft: false\n    };\n    this.shoot = false;\n    /* Cartesian Value of movement */\n\n    this.cartesianValueOfMovement = {\n      x: 0,\n      y: 0\n    };\n    /* Callbacks */\n\n    this.emitPosition = emitPosition;\n    this.emitBullet = emitBullet;\n    this.emitReload = emitReload;\n    this.addListeners();\n  }\n  /* Add keyboard listeners */\n\n\n  _createClass(Keyboard, [{\n    key: \"addListeners\",\n    value: function addListeners() {\n      var _this = this;\n\n      window.addEventListener('keydown', function (e) {\n        switch (e.key.toLowerCase()) {\n          case 'arrowup':\n            _this.controls.goUp = true;\n            _this.cartesianValueOfMovement.y = _this.controls.goDown ? 0 : 1;\n            break;\n\n          case 'arrowdown':\n            _this.controls.goDown = true;\n            _this.cartesianValueOfMovement.y = _this.controls.goUp ? 0 : -1;\n            break;\n\n          case 'arrowleft':\n            _this.controls.goLeft = true;\n            _this.cartesianValueOfMovement.x = _this.controls.goRight ? 0 : -1;\n            break;\n\n          case 'arrowright':\n            _this.controls.goRight = true;\n            _this.cartesianValueOfMovement.x = _this.controls.goLeft ? 0 : 1;\n            break;\n\n          case 'a':\n            _this.shoot = true;\n            break;\n\n          case 'r':\n            _this.emitReload();\n\n            break;\n        }\n      });\n      window.addEventListener('keyup', function (e) {\n        switch (e.key.toLowerCase()) {\n          case 'arrowup':\n            _this.character.onMovingStop();\n\n            _this.controls.goUp = false;\n            _this.cartesianValueOfMovement.y = _this.controls.goDown ? -1 : 0;\n            break;\n\n          case 'arrowdown':\n            _this.character.onMovingStop();\n\n            _this.controls.goDown = false;\n            _this.cartesianValueOfMovement.y = _this.controls.goUp ? 1 : 0;\n            break;\n\n          case 'arrowleft':\n            _this.character.onMovingStop();\n\n            _this.controls.goLeft = false;\n            _this.cartesianValueOfMovement.x = _this.controls.goRight ? 1 : 0;\n            break;\n\n          case 'arrowright':\n            _this.character.onMovingStop();\n\n            _this.controls.goRight = false;\n            _this.cartesianValueOfMovement.x = _this.controls.goLeft ? -1 : 0;\n            break;\n\n          case 'a':\n            _this.shoot = false;\n            break;\n        }\n\n        _this.emitPosition({\n          x: 0,\n          y: 0\n        });\n      });\n    }\n    /**\r\n     * ==========================\r\n     *      Animate Character\r\n     * ==========================\r\n     */\n\n    /* Animating local character using data from server */\n\n  }, {\n    key: \"animate\",\n    value: function animate() {\n      var movement = {\n        x: 0,\n        y: 0\n      };\n\n      if (this.controls.goUp && this.controls.goLeft) {\n        movement.x = -Math.sin(Math.PI / 4);\n        movement.y = -Math.sin(Math.PI / 4);\n\n        if (this.character.currentSprite.y != 3) {\n          this.character.onMovingStop();\n          this.character.onMovingForwardLeft();\n        }\n      }\n\n      if (this.controls.goUp && this.controls.goRight) {\n        movement.x = Math.sin(Math.PI / 4);\n        movement.y = -Math.sin(Math.PI / 4);\n\n        if (this.character.currentSprite.y != 3) {\n          this.character.onMovingStop();\n          this.character.onMovingForwardRight();\n        }\n      }\n\n      if (this.controls.goDown && this.controls.goRight) {\n        movement.x = Math.sin(Math.PI / 4);\n        movement.y = Math.sin(Math.PI / 4);\n\n        if (this.character.currentSprite.y != 4) {\n          this.character.onMovingStop();\n          this.character.onMovingBackwardsRight();\n        }\n      }\n\n      if (this.controls.goDown && this.controls.goLeft) {\n        movement.x = -Math.sin(Math.PI / 4);\n        movement.y = Math.sin(Math.PI / 4);\n\n        if (this.character.currentSprite.y != 4) {\n          this.character.onMovingStop();\n          this.character.onMovingBackwardsLeft();\n        }\n      }\n\n      if (this.controls.goUp) {\n        movement.y = this.controls.goDown ? 0 : -1;\n        if (!this.character.moveInterval) this.character.onMovingForward();\n      }\n\n      if (this.controls.goDown) {\n        movement.y = this.controls.goUp ? 0 : 1;\n        if (!this.character.moveInterval) this.character.onMovingBackwards();\n      }\n\n      if (this.controls.goRight) {\n        movement.x = this.controls.goLeft ? 0 : 1;\n        if (!this.character.moveInterval) this.character.onMovingRight();\n      }\n\n      if (this.controls.goLeft) {\n        movement.x = this.controls.goRight ? 0 : -1;\n        if (!this.character.moveInterval) this.character.onMovingLeft();\n      }\n\n      if (this.shoot) this.createBullet();\n      if (movement.x !== 0 || movement.y !== 0) this.emitPosition(movement);\n    }\n  }, {\n    key: \"createBullet\",\n    value: function createBullet() {\n      /* Position on bullet sprite (Y) */\n      var spriteY = 0;\n      /* Direction of bullet */\n\n      var dir = {\n        x: 0,\n        y: 0\n      };\n\n      switch (this.character.currentSprite.y) {\n        case 0:\n          dir.x = 0;\n          dir.y = 1;\n          spriteY = 0;\n          break;\n\n        case 1:\n          dir.y = 0;\n          dir.x = 1 * this.character.currentSprite.flip;\n          spriteY = 2;\n          break;\n\n        case 2:\n          dir.x = 0;\n          dir.y = -1;\n          spriteY = 0;\n          break;\n\n        case 3:\n          dir.y = -Math.sin(Math.PI / 4);\n          dir.x = Math.sin(Math.PI / 4) * this.character.currentSprite.flip;\n          spriteY = 1;\n          break;\n\n        case 4:\n          dir.y = Math.sin(Math.PI / 4);\n          dir.x = Math.sin(Math.PI / 4) * this.character.currentSprite.flip;\n          spriteY = 3;\n          break;\n\n        case 5:\n          dir.x = 1 * this.character.currentSprite.flip;\n          dir.y = 0;\n          spriteY = 2;\n          break;\n      }\n\n      this.emitBullet(dir, spriteY);\n    }\n  }]);\n\n  return Keyboard;\n}();\n\n\n\n//# sourceURL=webpack:///./server/client/js/classes/Keyboard.js?");

/***/ }),

/***/ "./server/client/js/classes/Online.js":
/*!********************************************!*\
  !*** ./server/client/js/classes/Online.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Online; });\n/* harmony import */ var _Engine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Engine.js */ \"./server/client/js/classes/Engine.js\");\n/* harmony import */ var _OnlineChat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OnlineChat.js */ \"./server/client/js/classes/OnlineChat.js\");\n/* harmony import */ var _Joystick_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Joystick.js */ \"./server/client/js/classes/Joystick.js\");\n/* harmony import */ var _Keyboard_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Keyboard.js */ \"./server/client/js/classes/Keyboard.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n/**\r\n * ================================\r\n *      ONLINE GAME ENGINE\r\n * ================================\r\n */\n\nvar Online = /*#__PURE__*/function (_Engine) {\n  _inherits(Online, _Engine);\n\n  var _super = _createSuper(Online);\n\n  function Online(map, colissionMatrix, shadowMatrix, tileSet, canvas, socket, playerID, server, skin, name, game) {\n    var _this;\n\n    _classCallCheck(this, Online);\n\n    _this = _super.call(this, map, colissionMatrix, shadowMatrix, tileSet, canvas, skin);\n\n    _this.render = function (timeSinceLastFrame) {\n      _this.context.clearRect(0, 0, _this.canvas.width, _this.canvas.height);\n\n      if (_this.playerStats) _this.calculateLocalMap();\n\n      _this.calculateOffset();\n\n      _this.drawMap();\n\n      _this.drawShadows();\n\n      _this.drawObjects();\n\n      _this.drawBullets();\n\n      _this.drawOtherPlayers();\n\n      _this.controls.animate();\n\n      _this.context.font = '16px cursive';\n      _this.context.fillStyle = 'black';\n\n      if (Date.now() - _this.lastStillUpdate >= _this.character.animationSpeed) {\n        _this.staticAnimation.x++;\n        if (_this.staticAnimation.x === 3) _this.staticAnimation.x = 0;\n        _this.lastStillUpdate = Date.now();\n      } //this.drawCharacter()\n\n\n      _this.context.fillStyle = \"black\";\n\n      _this.context.fillText(\"FPS: \".concat(_this.FPS), _this.screenTiles.x * _this.tile.height - 100, 50);\n\n      _this.context.fillText(\"Net: \".concat(_this.latency, \"ms\"), _this.screenTiles.x * _this.tile.height - 100, 70);\n\n      if (_this.reloading || _this.currentAmmo === 0) {\n        _this.context.textAlign = 'center';\n\n        _this.context.fillText('Reloading...', _this.screenTiles.x * _this.tile.width / 2, _this.canvas.height - 10);\n      }\n\n      requestAnimationFrame(function () {\n        /* FPS Counter */\n        var now = new Date();\n        timeSinceLastFrame = _this.lastFrameTime ? now - _this.lastFrameTime : 0;\n\n        _this.render(timeSinceLastFrame);\n\n        _this.lastFrameTime = now;\n        _this.FPS = Math.floor(1 / (timeSinceLastFrame / 1000));\n      });\n    };\n\n    _this.emitPlayerPosition = function (movement) {\n      _this.socketIO.emit('movement', {\n        movement: movement,\n        cartisianMovement: _this.controls.cartesianValueOfMovement,\n        character: {\n          currentSprite: _this.character.currentSprite\n        }\n      });\n    };\n\n    _this.emitReload = function () {\n      if (_this.currentAmmo !== _this.playerAmmunition) {\n        _this.reloading = true;\n\n        _this.socketIO.emit('reload weapon');\n      }\n    };\n\n    _this.controls = window.mobileCheck() ? new _Joystick_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](_this.canvas, _this.character, _this.emitPlayerPosition, _this.triggerShooting) : new _Keyboard_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_this.character, _this.emitPlayerPosition, _this.triggerShooting, _this.emitReload, _this.playerStats);\n    _this.name = name;\n    _this.serverDelay = null;\n    /* Online attributes recevied from the sever */\n\n    _this.playerID = playerID;\n    _this.socketIO = socket;\n    /* Create a chat room */\n\n    _this.chat = new _OnlineChat_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](_this.socketIO);\n    /* Add to emit => the skin */\n\n    _this.socketIO.emit('New Player', {\n      name: _this.name,\n      skin: _this.skin,\n      character: _this.character.currentSprite,\n      game: game\n    });\n\n    _this.state = null;\n    _this.server = server;\n    /* CALCULATE network speed */\n\n    _this.latency = 0;\n    /* Skins array of images */\n\n    _this.onlineSkins = {};\n    /* Check change on cartesian value of movement */\n\n    _this.cartesianChange = {\n      x: false,\n      y: false\n    };\n    /* INTERPOLATION */\n\n    _this.buffer = [];\n    /* Constant of interpolation delay */\n\n    _this.interpolationDelay = 50;\n    /* SOCKET LISTENERS */\n\n    _this.socketIO.on('state', function (data) {\n      if (_this.buffer.length == 0) {\n        _this.state = data;\n\n        _this.updateState();\n      }\n\n      _this.buffer.push(data);\n      /* Add interpolation */\n\n\n      setTimeout(function () {\n        /* Dequeue from buffer */\n        _this.state = _this.buffer[0];\n\n        _this.buffer.splice(0, 1);\n\n        _this.updateState();\n      }, _this.interpolationDelay);\n      _this.serverDelay = Date.now() - data.serverTime;\n    });\n    /* When new players enter the lobby, they must load other users skins and default info about the skin selected */\n\n\n    _this.socketIO.on('Load Skins and ammunition', function (data) {\n      data.srcArray.forEach(function (value) {\n        if (value != _this.skin) {\n          _this.loadServerSkin(value);\n        }\n      });\n      _this.playerAmmunition = data.characterInfo.bullets;\n      _this.currentAmmo = _this.playerAmmunition;\n      _this.shootingDelay = data.characterInfo.shootingDelay;\n      _this.bulletsHTMLElement.innerText = \"\".concat(_this.currentAmmo, \"/\").concat(_this.playerAmmunition);\n    });\n    /* when a new player enters, other people must load his skin */\n\n\n    _this.socketIO.on('Load New Skin', function (data) {\n      var element = _this.onlineSkins[data.src];\n      if (!element && data.src != _this.skin) _this.loadServerSkin(data.src);\n    });\n    /* When the score changes */\n\n\n    _this.socketIO.on('New leaderboard', function (data) {\n      var positions = ['trophy', 'medal', 'award'];\n      var score = document.getElementById('scores');\n      score.innerHTML = '';\n      data.map(function (elem, index) {\n        var text = document.createElement('p');\n        if (elem.id === _this.playerID) text.style.color = '#f0565e';\n        var scoreText = \"<i class=\\\"fas fa-\".concat(positions[index], \"\\\"></i>.\").concat(elem.name, \": \").concat(elem.score);\n        text.innerHTML = scoreText;\n        score.appendChild(text);\n      });\n    });\n    /* Scores from a team based lobby */\n\n\n    _this.socketIO.on('New teams leaderboard', function (data) {\n      document.getElementById('fbi-score').innerHTML = data.team1;\n      document.getElementById('gambinos-score').innerHTML = data.team2;\n    });\n\n    _this.socketIO.on('pong', function (ms) {\n      _this.latency = ms;\n    });\n    /* Still players animation */\n\n\n    _this.lastStillUpdate = Date.now();\n    return _this;\n  }\n  /**\r\n   * ==========================\r\n   *      RENDER FUNCTION\r\n   * ==========================\r\n   * \r\n   * Called once sprites are loaded by the engine\r\n   */\n\n\n  _createClass(Online, [{\n    key: \"calculateLocalMap\",\n\n    /* Calculates the position of the map in the browser => startX and startY */\n    value: function calculateLocalMap() {\n      var serverWidth = this.transformServerMagnitudesX(this.playerStats.posX);\n      var serverHeight = this.transformServerMagnitudesY(this.playerStats.posY);\n      /* X axis smoothness */\n\n      if (this.cameraSmoothness.offsetX < this.cameraSmoothness.limitX && this.cameraSmoothness.offsetX > -this.cameraSmoothness.limitX && this.playerStats.cartesianValueOfMovement.x) {\n        this.cameraSmoothness.velX = this.cameraSmoothness.velX > 1.8 ? 2 : this.cameraSmoothness.velX / this.cameraSmoothness.friction;\n        this.cameraSmoothness.offsetX += this.cameraSmoothness.velX * this.playerStats.cartesianValueOfMovement.x;\n      } else if ((this.playerStats.cartesianValueOfMovement.x > 0 && this.cameraSmoothness.offsetX < 0 || this.playerStats.cartesianValueOfMovement.x < 0 && this.cameraSmoothness.offsetX > 0 || this.playerStats.cartesianValueOfMovement.x === 0) && this.cameraSmoothness.offsetX !== 0) {\n        this.cameraSmoothness.velX = this.cameraSmoothness.velX <= .4 ? .4 : this.cameraSmoothness.velX * this.cameraSmoothness.friction;\n        if (this.cameraSmoothness.offsetX < 0) this.cameraSmoothness.offsetX += this.cameraSmoothness.velX;else this.cameraSmoothness.offsetX -= this.cameraSmoothness.velX;\n      }\n      /* Y axis smootheness */\n\n\n      if (this.cameraSmoothness.offsetY < this.cameraSmoothness.limitX && this.cameraSmoothness.offsetY > -this.cameraSmoothness.limitX && this.playerStats.cartesianValueOfMovement.y) {\n        this.cameraSmoothness.velY = this.cameraSmoothness.velY > 1.7 ? 2 : this.cameraSmoothness.velY / this.cameraSmoothness.friction;\n        this.cameraSmoothness.offsetY += this.cameraSmoothness.velY * (this.playerStats.cartesianValueOfMovement.y * -1);\n      } else if ((this.playerStats.cartesianValueOfMovement.y < 0 && this.cameraSmoothness.offsetY < 0 || this.playerStats.cartesianValueOfMovement.y > 0 && this.cameraSmoothness.offsetY > 0 || this.playerStats.cartesianValueOfMovement.y === 0) && this.cameraSmoothness.offsetY !== 0) {\n        this.cameraSmoothness.velY = this.cameraSmoothness.velY <= .4 ? .4 : this.cameraSmoothness.velY * this.cameraSmoothness.friction;\n        if (this.cameraSmoothness.offsetY < 0) this.cameraSmoothness.offsetY += this.cameraSmoothness.velY;else this.cameraSmoothness.offsetY -= this.cameraSmoothness.velY;\n      } //console.log(`x: ${this.cameraSmoothness.offsetX}, y: ${this.cameraSmoothness.offsetY}`)\n\n      /* Offset smooth camera */\n\n\n      this.tileMap.startX = this.screenTiles.x * this.tile.width / 2 - this.tile.width / 2 - serverWidth + this.cameraSmoothness.offsetX;\n      this.tileMap.startY = this.screenTiles.y * this.tile.height / 2 - this.tile.height / 2 - serverHeight + this.cameraSmoothness.offsetY;\n    }\n    /* Loops server players and calls the drawOnlineCharacter to draw each player with the data from the socket */\n\n  }, {\n    key: \"drawOtherPlayers\",\n    value: function drawOtherPlayers() {\n      if (Array.isArray(this.state.players)) {\n        var colors = this.state.players[0][this.playerID] ? [this.colors.ally, this.colors.enemy] : [this.colors.enemy, this.colors.ally];\n        this.drawPlayers(this.state.players[0], colors[0]);\n        this.drawPlayers(this.state.players[1], colors[1]);\n      } else {\n        this.drawPlayers(this.state.players);\n      }\n    }\n  }, {\n    key: \"drawPlayers\",\n    value: function drawPlayers(players) {\n      var lifeColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.colors.enemy;\n      var quitePlayers = false;\n\n      for (var playerID in players) {\n        var characterX = this.transformServerMagnitudesX(players[playerID].posX) + this.tileMap.startX;\n        var characterY = this.transformServerMagnitudesY(players[playerID].posY) + this.tileMap.startY;\n        /* If the character is outside the screen don't draw it */\n\n        if (characterX + this.tile.width >= 0 && characterX < this.screenTiles.x * this.tile.width && characterY + this.tile.height >= 0 && characterY < this.screenTiles.y * this.tile.height && players[playerID].character) {\n          var skin = players[playerID].skin == this.skin ? this.character.spriteSheet.img : this.onlineSkins[players[playerID].skin];\n          /* Check if any player is still */\n\n          if (players[playerID].still && players[playerID].life > 0) quitePlayers = true;\n\n          if (skin) {\n            var color = playerID === this.playerID ? this.colors.self : lifeColor;\n            this.drawLife(characterX, characterY - 6, players[playerID].life, color);\n            var character = {\n              flip: players[playerID].character.currentSprite.y === 0 || players[playerID].character.currentSprite.y === 2 ? 1 : players[playerID].character.currentSprite.flip,\n              y: players[playerID].shooting && players[playerID].life > 0 ? players[playerID].character.currentSprite.y + 6 : players[playerID].character.currentSprite.y,\n              x: players[playerID].still && players[playerID].life > 0 ? this.staticAnimation.x : players[playerID].character.currentSprite.x\n            };\n            this.drawOnlineCharacter({\n              posX: characterX,\n              posY: characterY\n            }, character, skin, players[playerID].playerName);\n          }\n        }\n      }\n\n      return quitePlayers;\n    }\n    /* Draws online players from server's data */\n\n  }, {\n    key: \"drawOnlineCharacter\",\n    value: function drawOnlineCharacter(player, onlineCharacter, skin, name) {\n      this.context.textAlign = 'center';\n      this.context.fillStyle = 'black';\n      this.context.fillText(name, player.posX + this.tile.width / 2, player.posY - 10);\n      this.context.save();\n      this.context.scale(onlineCharacter.flip, 1);\n      var posX = onlineCharacter.flip === 1 ? player.posX : player.posX * onlineCharacter.flip - this.tile.width;\n      this.context.drawImage(skin, onlineCharacter.x * this.character.spriteSheet.width, onlineCharacter.y * this.character.spriteSheet.height, this.character.spriteSheet.width, this.character.spriteSheet.height, posX, player.posY, this.tile.width, this.tile.height);\n      this.context.restore();\n    }\n    /* Uses the rule of three mathematic formula to transform values from the server */\n\n  }, {\n    key: \"transformServerMagnitudesX\",\n    value: function transformServerMagnitudesX(serverValue) {\n      return this.tileMap.width * serverValue / this.server.width;\n    }\n  }, {\n    key: \"transformServerMagnitudesY\",\n    value: function transformServerMagnitudesY(serverValue) {\n      return this.tileMap.height * serverValue / this.server.height;\n    }\n    /* Load new skin from the server */\n\n  }, {\n    key: \"loadServerSkin\",\n    value: function loadServerSkin(src) {\n      var characterSkin = new Image();\n      characterSkin.src = \"../assets/characters/\".concat(src, \".png\");\n      this.onlineSkins[src] = characterSkin;\n    }\n    /** \r\n     * =========================\r\n     *      Bullet Mechanics\r\n     * =========================\r\n    */\n\n    /* Draw bullets contain on the server */\n\n  }, {\n    key: \"drawBullets\",\n    value: function drawBullets() {\n      var _this2 = this;\n\n      if (this.state.bullets.length > 0) {\n        this.state.bullets.map(function (element) {\n          var bulletX = _this2.transformServerMagnitudesX(element.posX) + _this2.tileMap.startX;\n\n          var bulletY = _this2.transformServerMagnitudesY(element.posY) + _this2.tileMap.startY;\n\n          if (bulletX >= 0 && bulletX < _this2.screenTiles.x * _this2.tile.width && bulletY >= 0 && bulletY < _this2.screenTiles.y * _this2.tile.height) {\n            _this2.context.save();\n\n            _this2.context.scale(element.flip, 1);\n\n            var posX = element.flip === 1 ? bulletX : bulletX * element.flip;\n            var spritePosX = 0;\n            var spritePosY = element.spriteY * 16;\n\n            if (element.spriteY === 0) {\n              spritePosX += 5;\n              posX -= _this2.canvas.width * .005;\n            } else if (element.spriteY === 1) posX -= _this2.canvas.width * .015;else if (element.spriteY === 2) bulletY -= _this2.canvas.width * .01;\n\n            _this2.context.drawImage(_this2.bulletSprite.img, spritePosX, spritePosY, 16, 16, posX, bulletY, _this2.bulletSprite.width, _this2.bulletSprite.height);\n\n            _this2.context.restore();\n            /* Draw actual trayectory of the bullet */\n\n            /*\r\n            this.context.beginPath()\r\n            this.context.arc(this.transformServerMagnitudesX(element.posX)+this.tileMap.startX, this.transformServerMagnitudesY(element.posY) +this.tileMap.startY, 5, 0, 2 * Math.PI)\r\n            this.context.fill()\r\n            */\n\n          }\n        });\n      }\n    }\n    /** Update state */\n\n  }, {\n    key: \"updateState\",\n    value: function updateState() {\n      /* Set player stats when packet's been interpolated */\n      var currentPlayerPos;\n      if (Array.isArray(this.state.players)) currentPlayerPos = this.state.players[0][this.playerID] || this.state.players[1][this.playerID];else currentPlayerPos = this.state.players[this.playerID];\n      this.playerStats = currentPlayerPos;\n\n      if (this.playerStats) {\n        if (this.currentAmmo !== this.playerStats.bulletsCharger) {\n          this.currentAmmo = this.playerStats.currentAmmo;\n          this.bulletsHTMLElement.innerText = \"\".concat(this.currentAmmo, \"/\").concat(this.playerAmmunition);\n        }\n        /* Check if the player is reloading */\n\n\n        this.reloading = this.playerStats.reloading;\n      }\n    }\n    /* Emit bullet to server */\n\n  }, {\n    key: \"emitBullet\",\n    value: function emitBullet(dir, spriteY) {\n      this.socketIO.emit('shoot', {\n        bullet: {\n          dir: dir,\n          spriteY: spriteY\n        },\n        shootTime: Date.now() - this.serverDelay\n      });\n    }\n  }]);\n\n  return Online;\n}(_Engine_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n\n//# sourceURL=webpack:///./server/client/js/classes/Online.js?");

/***/ }),

/***/ "./server/client/js/classes/OnlineChat.js":
/*!************************************************!*\
  !*** ./server/client/js/classes/OnlineChat.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return OnlineChat; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n     * =================================\r\n     *      Online Chat Manager\r\n     * =================================\r\n     */\nvar OnlineChat = /*#__PURE__*/function () {\n  function OnlineChat(socketIO) {\n    _classCallCheck(this, OnlineChat);\n\n    /* Initialize Parent's socket */\n    this.socketIO = socketIO;\n    /* Default it will be false */\n\n    this.active = false;\n    /* Get chat settings */\n\n    this.inputChat = document.getElementById('chat-message');\n    this.messages = document.getElementById('chatMessages');\n    /* Add controls */\n\n    this.addChatControls();\n    this.addSocketListeners();\n  }\n  /** \r\n   * =============================\r\n   *      add Listeners\r\n   * =============================\r\n  */\n\n\n  _createClass(OnlineChat, [{\n    key: \"addChatControls\",\n    value: function addChatControls() {\n      var _this = this;\n\n      this.inputChat.onfocus = function () {\n        return _this.active = true;\n      };\n\n      this.inputChat.onblur = function () {\n        return _this.active = false;\n      };\n\n      window.addEventListener('keydown', function (e) {\n        if (e.key.toLowerCase() == 'enter') {\n          if (_this.active) {\n            _this.inputChat.blur();\n\n            _this.emitMessage();\n          } else _this.inputChat.focus();\n        }\n      });\n    }\n  }, {\n    key: \"addSocketListeners\",\n    value: function addSocketListeners() {\n      var _this2 = this;\n\n      this.socketIO.on('new Chat Message', function (data) {\n        /* Create message HTML node */\n        var message = document.createElement('p');\n        message.className = 'single-comment';\n        message.innerHTML = \"<span> \".concat(data.name, \"</span>: \").concat(data.text);\n\n        _this2.messages.append(message);\n        /* Scroll to the new message */\n\n\n        _this2.messages.scroll(0, _this2.messages.scrollHeight);\n      });\n      this.socketIO.on('banned', function (data) {\n        window.location.replace(window.location.href);\n      });\n    }\n    /**\r\n     * ================================\r\n     *  Emit Messages througth socket\r\n     * ================================\r\n     */\n\n  }, {\n    key: \"emitMessage\",\n    value: function emitMessage() {\n      /* Emit the message */\n      var url = new URLSearchParams(window.location.search);\n      var adminID = url.get('adminID');\n\n      if (this.inputChat.value != '') {\n        this.socketIO.emit('Chat Message', {\n          text: this.inputChat.value,\n          adminID: adminID\n        });\n        /* Reset the content */\n\n        this.inputChat.value = \"\";\n      }\n    }\n  }]);\n\n  return OnlineChat;\n}();\n\n\n\n//# sourceURL=webpack:///./server/client/js/classes/OnlineChat.js?");

/***/ }),

/***/ "./server/client/js/teams.js":
/*!***********************************!*\
  !*** ./server/client/js/teams.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_classes_Online_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../js/classes/Online.js */ \"./server/client/js/classes/Online.js\");\n\n/**\r\n * ==================================\r\n *          Team Deathmatch\r\n * ==================================\r\n */\n\n/* Creating the Glide object to show the available skins */\n\nvar play = document.getElementById('play');\n/* HTML body */\n\nvar body = document.getElementsByTagName('body')[0];\n/* select team screen */\n\nvar selectTeam = document.getElementById('select-teams');\n/* Start server */\n\nvar socket = io();\nvar game;\n/* Player name */\n\nvar name;\n/* Players in the lobby */\n\nvar players;\n/**\r\n *  =================================\r\n *      ADD SELECT TEAMS LISTENERS\r\n *  =================================\r\n */\n\nvar selectRedTeam = document.getElementById('site-red-team');\nvar selectBlueTeam = document.getElementById('site-blue-team');\n/* listeners callback */\n\nvar callback = function callback(e) {\n  var team = e.target.id === 'site-blue-team' ? 0 : 1;\n  /* show background when a team has been selected */\n\n  document.getElementById('background-frame').style.display = 'block';\n  document.getElementById('site-ajax-loader').style.display = 'block';\n  body.removeChild(selectTeam);\n  var engine = new _js_classes_Online_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](game.lobby.map, game.lobby.collisionMatrix, game.lobby.shadowMap, game.lobby.tileSet, document.getElementById('game'), socket, game.playerID, game.lobby.server, characterSkins[glide.index], name, {\n    mode: 1,\n    team: team\n  });\n};\n/* Enter red team */\n\n\nselectRedTeam.onclick = callback;\n/* Enter blue team */\n\nselectBlueTeam.onclick = callback;\n/**\r\n *  =======================================\r\n *      PLAYER HAS SELECTED A CHARACTER\r\n *  =======================================\r\n */\n\nplay.onclick = function () {\n  name = document.getElementById('playerName').value || 'unnamed';\n  /* remove select characters frame */\n\n  body.removeChild(document.getElementById('login-frame'));\n  /* show select teams screen */\n\n  selectTeam.style.display = 'block';\n  /* hide background until a team's been selected */\n\n  document.getElementById('background-frame').style.display = 'none';\n  /* Show current players in lobby */\n\n  displayPlayers(players.blues, document.getElementById('blue-team-players'));\n  displayPlayers(players.reds, document.getElementById('red-team-players'));\n};\n\nsocket.on('loadMap', function (data) {\n  game = data;\n});\nsocket.on('load team members', function (data) {\n  players = data;\n});\n/* Display players on the lobby */\n\nfunction displayPlayers(players, div) {\n  players.map(function (player) {\n    /* External player's div */\n    var divPlayer = document.createElement('div');\n    divPlayer.className = \"lobby-player\";\n    /* Playername */\n\n    var playerName = document.createElement('p');\n    playerName.innerHTML = player.name;\n    divPlayer.append(images.find(function (image) {\n      return image.src.includes(player.skin);\n    }).cloneNode());\n    divPlayer.append(playerName);\n    div.append(divPlayer);\n  });\n}\n\n//# sourceURL=webpack:///./server/client/js/teams.js?");

/***/ })

/******/ });